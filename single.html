<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover">
  <link href='https://fonts.googleapis.com/css?family=Racing Sans One' rel='stylesheet'>
  <link rel="icon" href="https://raw.githubusercontent.com/over-lords/overlords/4c614c1ffe5a9d7194202bd24fae5e7c99d86333/Public/Images/Site%20Assets/favicon.png" type="image/png">
  <link rel="stylesheet" href="style.css">
  <title>Overlords</title>
  <style>
  .hero-box {
  background-color: rgba(255, 255, 255, 0.9);
  border: none;                  /* remove inner border so it blends into dropdown */
  border-radius: 0 0 6px 6px;    /* keep rounded bottom to match dropdown */
  margin: 0;                     /* remove outside margins */
  padding: 15px;
  width: 100%;                   /* fill full dropdown width */
  box-sizing: border-box;        /* include padding in total width */
}
.hero-controls {
  display: flex;
  justify-content: center;
  gap: 15px;
  margin-bottom: 15px;
}
.hero-controls button {
  background-color: yellow;
  border: 2px solid black;
  border-radius: 4px;
  font-weight: bold;
  padding: 5px 12px;
  cursor: pointer;
}

.top-row {
  width: 95%;
  max-width: 1200px;
  margin: 10px auto 20px auto;
  display: flex;
  align-items: center;
  justify-content: space-between;
  position: relative;
}

.import-btn {
  background-color: yellow;
  border: 2px solid black;
  border-radius: 4px;
  font-weight: bold;
  padding: 6px 12px;
  cursor: pointer;
  position: absolute;
  left: 0;
}

.top-random-btn {
  background-color: yellow;
  border: 2px solid black;
  border-radius: 4px;
  font-weight: bold;
  padding: 6px 12px;
  cursor: pointer;
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
}

/* --- BOTTOM ROW --- */
.bottom-row {
  width: 95%;
  max-width: 1200px;
  margin: 25px auto 40px auto;
  display: flex;
  align-items: center;
  justify-content: space-between;
  position: relative;
}

.start-button {
  background-color: gray;
  border: 3px solid black;
  border-radius: 6px;
  color: black;
  font-weight: bold;
  font-size: 1.2rem;
  width: 250px;
  text-align: center;
  padding: 10px;
  cursor: not-allowed;
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
}

.start-button.active {
  background-color: yellow;
  cursor: pointer;
}

.export-btn {
  background-color: yellow;
  border: 2px solid black;
  border-radius: 4px;
  font-weight: bold;
  padding: 8px 16px;
  cursor: pointer;
  position: absolute;
  right: 0;
}
  /* Category container – wraps heroes into responsive rows */
  .category-group {
    border: 2px solid black;
    border-radius: 6px;
    margin: 15px 0;
    padding: 10px;
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 15px;
  }
  .guardian-bg { background-color: rgba(173, 216, 230, 0.5); }  /* Light blue */
  .striker-bg  { background-color: rgba(255, 182, 193, 0.5); }  /* Light red */
  .tactician-bg{ background-color: rgba(255, 255, 153, 0.5); }  /* Light yellow */

  .hero-category-title {
    flex-basis: 100%;
    text-align: center;
    font-weight: bold;
    font-size: 1.3rem;
    margin-bottom: 5px;
    text-shadow: 0 0 3px white;
  }

  .hero-card {
    text-align: center;
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
  }

  .hero-card img {
    width: 100px;
    height: 100px;
    object-fit: cover;
    border: 2px solid black;
    border-radius: 4px;
  }

  .hero-card.selected img {
    box-shadow: 0 0 10px 5px yellow;
    transform: scale(1.05);
  }

  .hero-card p {
    margin-top: 5px;
    font-weight: bold;
    font-size: 0.9rem;
  }

  .container {
    display: flex;
    flex-direction: column;
    align-items: center;
    }
  .collapsible {
  background-color: #5d5d5d;
  color: white;
  cursor: pointer;
  padding: 10px;
  width: 95%;
  max-width: 1200px;
  border: 2px solid black;
  border-radius: 6px;
  text-align: center;
  margin: 20px auto 0 auto;
  font-weight: bold;
  transition: border-radius 0.2s ease, border-bottom 0.2s ease;
  box-sizing: border-box;
}

.collapsible.active {
  background-color: #777;
  border-bottom: none;
  border-radius: 6px 6px 0 0;
}

.content {
  display: none;
  overflow: hidden;
  width: 95%;
  max-width: 1200px;
  margin: 0 auto;
  border: 2px solid black;
  border-top: none;             /* merge with open button border */
  border-radius: 0 0 6px 6px;
  box-sizing: border-box;       /* ensures exact same width */
}

.content.show {
  display: block;
}

  .start-button {
    background-color: gray;
    border: 3px solid black;
    border-radius: 6px;
    color: black;
    font-weight: bold;
    font-size: 1.2rem;
    width: 250px;
    text-align: center;
    margin: 20px auto;
    padding: 10px;
    cursor: not-allowed;
  }

  .start-button.active {
    background-color: yellow;
    cursor: pointer;
  }
  .boxed {
    display: inline-block;
    border: 3px solid black;
    background-color: rgba(255, 255, 255, 0.9);
    padding: 6px 10px;
    border-radius: 4px;
  }
  .hero-card { position: relative; }
.selection-badge {
  position: absolute;
  top: -6px;
  right: -6px;
  width: 26px;
  height: 26px;
  border-radius: 50%;
  background: yellow;
  border: 2px solid black;
  color: black;
  font-weight: 800;
  display: none;
  align-items: center;
  justify-content: center;
  font-size: 14px;
}
.hero-image-wrapper {
  position: relative;
  display: inline-block;  /* keeps wrapper tight to image */
}

.overlord-card {
  text-align: center;
  cursor: pointer;
  transition: transform 0.2s, box-shadow 0.2s;
  position: relative;
}

.overlord-card img {
  width: 100px;
  height: 100px;
  object-fit: cover;
  border: 2px solid black;
  border-radius: 6px;
}
.overlord-card.selected img {
  box-shadow: 0 0 12px 6px yellow;
  transform: scale(1.05);
}
.overlord-card p {
  margin: 5px 0;
  font-weight: bold;
}
.difficulty-1 {
  background-color: rgba(0, 255, 0, 0.2);
}
.difficulty-2 {
  background-color: rgba(255, 255, 0, 0.2);
}
.difficulty-3 {
  background-color: rgba(255, 0, 0, 0.2);
}
.difficulty-title {
  flex-basis: 100%;
  font-weight: bold;
  margin-top: 10px;
  text-align: center;
}
#tactics-grid {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 10px;
  margin-top: 10px;
}

.tactic-card {
  background-color: white;
  border: 2px solid black;
  border-radius: 12px;
  padding: 10px 15px;
  width: 80%;
  cursor: pointer;
  transition: transform 0.2s, box-shadow 0.2s;
  text-align: left;
  box-sizing: border-box;
}

.tactic-card:hover {
  transform: scale(1.02);
  box-shadow: 0 0 6px rgba(0,0,0,0.3);
}

.tactic-card.selected {
  box-shadow: 0 0 10px 4px yellow;
}

.tactic-card h3 {
  margin: 0;
  font-size: 1rem;
  font-weight: bold;
}

.tactic-card p {
  margin: 5px 0 0 0;
  font-size: 0.9rem;
}
</style>
</head>
    <body style="background-color:white;" onload="window.scrollTo(0, 1)">
        <div class="bg-image" alt="" style="opacity: 35%;"></div>
        <div class="container">
            <div class="title-box" id="title-box"></div>
            <h1 class="glow-red" style="pointer-events: none;">Overlords</h1>

            <div id="close-box" onclick="location.href='play.html'">X</div>

            <div class="container" style="margin-top: 110px; width: 100%;">
                <p class="boxed" style="font-weight: bold; font-family: 'Poppins', sans-serif;">Design your Singleplayer game!</p>
                <div class="top-row">
                  <button id="import-loadout" class="import-btn">Import Loadout</button>
                  <button id="top-random" class="top-random-btn">Random</button>
                </div>
                <button class="collapsible">Select Your Heroes (1-6)</button>
                <div class="content">
                <div class="hero-box">
                  <div class="hero-controls">
                    <button id="undo-random">Undo</button>
                    <button id="random-heroes">Random</button>
                    <button id="redo-random">Redo</button>
                  </div>
                    <div id="hero-grid" class="hero-grid"></div>
                </div>
                </div>

                <button class="collapsible">Select Your Overlords (1-3)</button>
                <div class="content">
                  <div class="hero-box">
                    <div class="hero-controls">
                      <button id="undo-overlords">Undo</button>
                      <button id="random-overlords">Random</button>
                      <button id="redo-overlords">Redo</button>
                    </div>
                    <div id="overlord-grid" class="hero-grid"></div>
                  </div>
                </div>

                <button class="collapsible">Select Your Tactics (1-2)</button>
                <div class="content">
                  <div class="hero-box" style="background-color: #ccc;">
                    <div class="hero-controls">
                      <button id="undo-tactics">Undo</button>
                      <button id="random-tactics">Random</button>
                      <button id="redo-tactics">Redo</button>
                    </div>
                    <div id="tactics-grid" class="hero-grid"></div>
                  </div>
                </div>

                <button class="collapsible">Enemies and Allies (15–50 each)</button>
                <div class="content">
                  <div class="hero-box" style="background-color: #ddd;">
                    <p style="font-weight:bold; margin-bottom:25px;">
                      Recommended 30 each for a total of 60
                    </p>

                    <div style="display:flex; flex-direction:column; gap:20px; align-items:center;">

                      <!-- ENEMIES SLIDER -->
                      <div style="display:flex; align-items:center; gap:10px; width:90%; max-width:600px;">
                        <label style="width:50px; text-align:right;">Enemies</label>
                        <div style="position:relative; flex:1;">
                          <input id="enemies-slider" type="range" min="0" max="50" value="0" step="1"
                                style="width:100%; cursor:pointer;">
                          <div id="enemies-value"
                              style="position:absolute; top:-15px; left:0; transform:translateX(0%);
                                      font-weight:bold; text-align:center;">0</div>
                        </div>
                        <label style="width:20px; text-align:center;"></label>
                        <input id="enemies-input" type="number" min="0" max="50" value="0"
                              style="width:60px; text-align:center;">
                      </div>

                      <!-- ALLIES SLIDER -->
                      <div style="display:flex; align-items:center; gap:10px; width:90%; max-width:600px;">
                        <label style="width:50px; text-align:right;">Allies</label>
                        <div style="position:relative; flex:1;">
                          <input id="allies-slider" type="range" min="0" max="50" value="0" step="1"
                                style="width:100%; cursor:pointer;">
                          <div id="allies-value"
                              style="position:absolute; top:-15px; left:0; transform:translateX(0%);
                                      font-weight:bold; text-align:center;">0</div>
                        </div>
                        <label style="width:20px; text-align:center;"></label>
                        <input id="allies-input" type="number" min="0" max="50" value="0"
                              style="width:60px; text-align:center;">
                      </div>

                      <div class="hero-controls">
                        <button id="undo-enemies">Undo</button>
                        <button id="random-enemies">Random</button>
                        <button id="redo-enemies">Redo</button>
                      </div>
                    </div>
                  </div>
                </div>

                <br>
                <div class="bottom-row">
                  <button id="start-button" class="start-button">Start Game!</button>
                  <button id="export-loadout" class="export-btn">Export Loadout</button>
                </div>
                <br><br><br>
            </div>
        </div>

        <script type="module">
            import { heroes } from './data/faceCards.js';
            import { overlords } from './data/overlords.js';
            import { tactics } from './data/tactics.js';
            import { enemies } from './data/enemies.js';
            import { allies } from './data/allies.js';

            const collapsible = document.querySelector('.collapsible');
            const content = document.querySelector('.content');

            const heroGrid = document.getElementById('hero-grid');
            const startButton = document.getElementById('start-button');

            document.querySelectorAll('.collapsible').forEach(button => {
              button.addEventListener('click', () => {
                button.classList.toggle('active');
                const content = button.nextElementSibling;
                if (content) content.classList.toggle('show');
              });
            });

            // Sort and filter heroes
            const filteredHeroes = heroes
                .filter(h => h.doNotShow !== "true")
                .sort((a, b) => {
                const order = { Guardian: 1, Striker: 2, Tactician: 3 };
                if (order[a.category] !== order[b.category]) return order[a.category] - order[b.category];
                return parseInt(a.id) - parseInt(b.id);
                });

            const categories = [
                { name: 'Guardian', class: 'guardian-bg' },
                { name: 'Striker', class: 'striker-bg' },
                { name: 'Tactician', class: 'tactician-bg' }
            ];

            // Render categories with wrapping grids
            categories.forEach(cat => {
                const catHeroes = filteredHeroes.filter(h => h.category === cat.name);
                if (!catHeroes.length) return;

                const section = document.createElement('div');
                section.classList.add('category-group', cat.class);

                const title = document.createElement('div');
                title.classList.add('hero-category-title');

                // Count only heroes that are not doNotShow:true
                const visibleCount = catHeroes.filter(h => h.doNotShow !== "true").length;

                // Add an 's' for pluralized category names
                title.textContent = `${cat.name}s (${visibleCount})`;

                section.appendChild(title);

                catHeroes.forEach(hero => {
                const card = document.createElement('div');
                card.classList.add('hero-card');
                card.dataset.id = hero.id;

                const img = document.createElement('img');
                img.src = hero.image;
                img.alt = hero.name;

                const name = document.createElement('p');
                name.textContent = hero.name;

                const badge = document.createElement('span');
                badge.className = 'selection-badge';
                badge.textContent = '';

                const wrapper = document.createElement('div');
                wrapper.className = 'hero-image-wrapper';
                wrapper.appendChild(img);
                wrapper.appendChild(badge);

                card.appendChild(wrapper);
                card.appendChild(name);
                section.appendChild(card);
                });

                heroGrid.appendChild(section);
            });

            // Keep ordered selection
            let selectedOrder = [];

            // Paint all badges and selected styles based on selectedOrder
            function updateBadges() {
              document.querySelectorAll('.hero-card').forEach(card => {
                const id = card.dataset.id;
                const idx = selectedOrder.indexOf(id);
                const badge = card.querySelector('.selection-badge');

                if (idx > -1) {
                  card.classList.add('selected');
                  if (badge) {
                    badge.style.display = 'flex';
                    badge.textContent = String(idx + 1);
                  }
                } else {
                  card.classList.remove('selected');
                  if (badge) {
                    badge.style.display = 'none';
                    badge.textContent = '';
                  }
                }
              });
            }

            heroGrid.addEventListener('click', e => {
              const card = e.target.closest('.hero-card');
              if (!card) return;

              const heroId = card.dataset.id;
              const idx = selectedOrder.indexOf(heroId);

              if (idx > -1) {
                // Deselect: remove and reindex others
                selectedOrder.splice(idx, 1);
              } else if (selectedOrder.length < 6) {
                // Select: append to the end; order matters
                selectedOrder.push(heroId);
              }

              updateBadges();
              updateStartButton();
            });

            // Encrypt data using AES-GCM with SHA-256–derived key
            async function encryptData(data, secretKey) {
              const enc = new TextEncoder();
              const iv = crypto.getRandomValues(new Uint8Array(12));

              // Derive a 256-bit key from any secret string
              const keyMaterial = await crypto.subtle.digest("SHA-256", enc.encode(secretKey));
              const key = await crypto.subtle.importKey(
                "raw",
                keyMaterial,
                { name: "AES-GCM" },
                false,
                ["encrypt"]
              );

              const encoded = enc.encode(JSON.stringify(data));
              const cipherBuffer = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, encoded);

              // Combine IV + ciphertext → base64
              const combined = new Uint8Array(iv.length + cipherBuffer.byteLength);
              combined.set(iv);
              combined.set(new Uint8Array(cipherBuffer), iv.length);
              return btoa(String.fromCharCode(...combined));
            }

            startButton.addEventListener("click", async () => {
              if (!startButton.classList.contains("active")) return;

              const SECRET = "GeimonHeroKey42";
              const payload = {
                heroes: selectedOrder,
                overlords: selectedOverlords,
                tactics: selectedTactics,
                enemies: enemiesCount,
                allies: alliesCount
              };

              const encrypted = await encryptData(payload, SECRET);
              const url = new URL("./game.html", window.location.href);
              url.searchParams.set("data", encrypted);
              window.location.href = url.toString();
            });

            // --- Randomization and Loadout Management ---
            let undoStack = [];
            let redoStack = [];

            // Utility: get all hero IDs not yet chosen
            function getUnselectedHeroes() {
              const allIds = Array.from(document.querySelectorAll('.hero-card')).map(c => c.dataset.id);
              return allIds.filter(id => !selectedOrder.includes(id));
            }

            // Utility: apply selected order visually
            function applySelection(order) {
              selectedOrder = order.slice();
              updateBadges();
              updateStartButton();
            }

            // Randomly fill remaining slots up to 6
            function randomizeSelection() {
              const maxSelectable = 6 - selectedOrder.length;
              if (maxSelectable <= 0) return;

              const available = getUnselectedHeroes();
              if (available.length === 0) return;

              // Choose a random number of new heroes between 1 and maxSelectable
              const countToAdd = Math.floor(Math.random() * maxSelectable) + 1;
              const toAdd = [];

              while (toAdd.length < countToAdd && available.length > 0) {
                const idx = Math.floor(Math.random() * available.length);
                toAdd.push(available.splice(idx, 1)[0]);
              }

              undoStack.push([...selectedOrder]);  // save pre-random state
              redoStack = [];                      // clear redo on new random
              selectedOrder = [...selectedOrder, ...toAdd];

              updateBadges();
              updateStartButton();
            }

            // Undo last random
            function undoRandom() {
              if (undoStack.length === 0) return;
              redoStack.push([...selectedOrder]);
              const prev = undoStack.pop();
              applySelection(prev);
            }

            // Redo last undone random
            function redoRandom() {
              if (redoStack.length === 0) return;
              undoStack.push([...selectedOrder]);
              const next = redoStack.pop();
              applySelection(next);
            }

            // --- Button bindings ---
            document.getElementById('random-heroes').addEventListener('click', randomizeSelection);
            document.getElementById('undo-random').addEventListener('click', undoRandom);
            document.getElementById('redo-random').addEventListener('click', redoRandom);
            document.getElementById('export-loadout').addEventListener('click', exportLoadout);

            // Create hidden file input for import
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.txt';
            fileInput.style.display = 'none';
            fileInput.addEventListener('change', importLoadout);
            document.body.appendChild(fileInput);

            document.getElementById('import-loadout').addEventListener('click', () => fileInput.click());

            // ==================== OVERLORD SECTION ====================
            const overlordGrid = document.getElementById('overlord-grid');
            let selectedOverlords = [];
            let overlordUndoStack = [];
            let overlordRedoStack = [];

            // Filter and group Overlords
            const filteredOverlords = overlords
              .filter(o => String(o.doNotShow).toLowerCase() !== "true")
              .map(o => ({
                ...o,
                level: Number(o.level),
                hp: Number(o.hp)
              }))
              .sort((a, b) => a.level - b.level || a.hp - b.hp);

            // Group by difficulty
            const difficulties = [
              { level: 1, colorClass: 'difficulty-1', label: 'Easy' },
              { level: 2, colorClass: 'difficulty-2', label: 'Medium' },
              { level: 3, colorClass: 'difficulty-3', label: 'Hard' }
            ];

            difficulties.forEach(diff => {
              const section = document.createElement('div');
              section.classList.add('category-group', diff.colorClass);

              const title = document.createElement('div');
              title.classList.add('difficulty-title');
              title.textContent = `Difficulty ${diff.level} (${diff.label})`;
              section.appendChild(title);

              const overlordGroup = filteredOverlords.filter(o => o.level === diff.level);
              overlordGroup.forEach(overlord => {
                const card = document.createElement('div');
                card.classList.add('overlord-card');
                card.dataset.id = overlord.id;
                card.dataset.level = overlord.level;
                card.dataset.hp = overlord.hp;

                const img = document.createElement('img');
                img.src = overlord.image;
                img.alt = overlord.name;

                const name = document.createElement('p');
                name.textContent = overlord.name;

                const hp = document.createElement('p');
                hp.textContent = `${overlord.hp} HP`;

                const badge = document.createElement('span');
                badge.className = 'selection-badge';

                const wrapper = document.createElement('div');
                wrapper.className = 'hero-image-wrapper';
                wrapper.appendChild(img);
                wrapper.appendChild(badge);

                card.appendChild(wrapper);
                card.appendChild(name);
                card.appendChild(hp);
                section.appendChild(card);
              });

              overlordGrid.appendChild(section);
            });

            // Update visuals
            function updateOverlordBadges() {
              document.querySelectorAll('.overlord-card').forEach(card => {
                const id = card.dataset.id;
                const idx = selectedOverlords.indexOf(id);
                const badge = card.querySelector('.selection-badge');

                if (idx > -1) {
                  card.classList.add('selected');
                  if (badge) {
                    badge.style.display = 'flex';
                    badge.textContent = String(idx + 1);
                  }
                } else {
                  card.classList.remove('selected');
                  if (badge) {
                    badge.style.display = 'none';
                    badge.textContent = '';
                  }
                }
              });
            }

            // Handle click
            overlordGrid.addEventListener('click', e => {
              const card = e.target.closest('.overlord-card');
              if (!card) return;
              const id = card.dataset.id;
              const idx = selectedOverlords.indexOf(id);

              if (idx > -1) {
                selectedOverlords.splice(idx, 1);
              } else if (selectedOverlords.length < 3) {
                selectedOverlords.push(id);
              }

              // Sort by difficulty, then HP
              const overlordData = overlords.filter(o => selectedOverlords.includes(String(o.id)));
              overlordData.sort((a, b) => a.level - b.level || a.hp - b.hp);
              selectedOverlords = overlordData.map(o => String(o.id));

              updateOverlordBadges();
              updateStartButton();
            });

            // Randomize Overlords
            function randomizeOverlords() {
              const maxSelectable = 3 - selectedOverlords.length;
              if (maxSelectable <= 0) return;

              const available = filteredOverlords
                .filter(o => !selectedOverlords.includes(String(o.id)));
              if (available.length === 0) return;

              const countToAdd = Math.max(1, Math.ceil(Math.random() * maxSelectable));
              const toAdd = [];

              while (toAdd.length < countToAdd && available.length > 0) {
                const idx = Math.floor(Math.random() * available.length);
                toAdd.push(available.splice(idx, 1)[0]);
              }

              overlordUndoStack.push([...selectedOverlords]);
              overlordRedoStack = [];

              const newSelection = [...selectedOverlords, ...toAdd.map(o => String(o.id))];
              const ordered = overlords
                .filter(o => newSelection.includes(String(o.id)))
                .sort((a, b) => a.level - b.level || a.hp - b.hp);
              selectedOverlords = ordered.map(o => String(o.id));

              updateOverlordBadges();
              updateStartButton();
            }

            function undoOverlords() {
              if (overlordUndoStack.length === 0) return;
              overlordRedoStack.push([...selectedOverlords]);
              selectedOverlords = overlordUndoStack.pop();
              updateOverlordBadges();
              updateStartButton();
            }

            function redoOverlords() {
              if (overlordRedoStack.length === 0) return;
              overlordUndoStack.push([...selectedOverlords]);
              selectedOverlords = overlordRedoStack.pop();
              updateOverlordBadges();
              updateStartButton();
            }

            // Button bindings
            document.getElementById('random-overlords').addEventListener('click', randomizeOverlords);
            document.getElementById('undo-overlords').addEventListener('click', undoOverlords);
            document.getElementById('redo-overlords').addEventListener('click', redoOverlords);

            // ==================== TACTICS SECTION ====================
            const tacticsGrid = document.getElementById('tactics-grid');
            let selectedTactics = [];
            let tacticsUndoStack = [];
            let tacticsRedoStack = [];

            // Filter and sort tactics alphabetically, ignoring doNotShow:true
            const filteredTactics = tactics
              .filter(t => String(t.doNotShow).toLowerCase() !== "true")
              .sort((a, b) => a.name.localeCompare(b.name));

            // Render tactics
            filteredTactics.forEach(t => {
              const card = document.createElement('div');
              card.classList.add('tactic-card');
              card.dataset.id = t.id;

              const title = document.createElement('h3');
              title.textContent = t.name;

              const desc = document.createElement('div');
              desc.innerHTML = t.abilitiesText
                ?.map(a => a.text)
                .join('<br><br>') || 'No effect listed.';
              desc.style.fontSize = '0.9rem';
              desc.style.marginTop = '5px';

              card.appendChild(title);
              card.appendChild(desc);
              tacticsGrid.appendChild(card);
            });

            // Update visuals
            function updateTacticStyles() {
              document.querySelectorAll('.tactic-card').forEach(card => {
                const id = card.dataset.id;
                if (selectedTactics.includes(id)) {
                  card.classList.add('selected');
                } else {
                  card.classList.remove('selected');
                }
              });
            }

            // Handle click selection
            tacticsGrid.addEventListener('click', e => {
              const card = e.target.closest('.tactic-card');
              if (!card) return;
              const id = card.dataset.id;
              const idx = selectedTactics.indexOf(id);

              if (idx > -1) {
                selectedTactics.splice(idx, 1);
              } else if (selectedTactics.length < 2) {
                selectedTactics.push(id);
              }

              updateTacticStyles();
              updateStartButton();
            });

            // Randomize Tactics
            function randomizeTactics() {
              const maxSelectable = 2 - selectedTactics.length;
              if (maxSelectable <= 0) return;

              const available = filteredTactics.filter(t => !selectedTactics.includes(String(t.id)));
              if (available.length === 0) return;

              const countToAdd = Math.floor(Math.random() * maxSelectable) + 1;
              const toAdd = [];

              while (toAdd.length < countToAdd && available.length > 0) {
                const idx = Math.floor(Math.random() * available.length);
                toAdd.push(available.splice(idx, 1)[0]);
              }

              tacticsUndoStack.push([...selectedTactics]);
              tacticsRedoStack = [];

              selectedTactics = [...selectedTactics, ...toAdd.map(t => String(t.id))];
              updateTacticStyles();
              updateStartButton();
            }

            function undoTactics() {
              if (tacticsUndoStack.length === 0) return;
              tacticsRedoStack.push([...selectedTactics]);
              selectedTactics = tacticsUndoStack.pop();
              updateTacticStyles();
              updateStartButton();
            }

            function redoTactics() {
              if (tacticsRedoStack.length === 0) return;
              tacticsUndoStack.push([...selectedTactics]);
              selectedTactics = tacticsRedoStack.pop();
              updateTacticStyles();
              updateStartButton();
            }

            // Add button bindings
            document.getElementById('random-tactics').addEventListener('click', randomizeTactics);
            document.getElementById('undo-tactics').addEventListener('click', undoTactics);
            document.getElementById('redo-tactics').addEventListener('click', redoTactics);

            // ==================== ENEMIES & ALLIES SECTION ====================
            const enemiesSlider = document.getElementById('enemies-slider');
            const alliesSlider = document.getElementById('allies-slider');
            const enemiesValue = document.getElementById('enemies-value');
            const alliesValue = document.getElementById('allies-value');
            const enemiesInput = document.getElementById('enemies-input');
            const alliesInput = document.getElementById('allies-input');

            let enemiesCount = 0;
            let alliesCount = 0;

            let enemiesUndoStack = [];
            let enemiesRedoStack = [];
            let alliesUndoStack = [];
            let alliesRedoStack = [];

            // Update the position label above each slider
            function updateSliderLabel(slider, label) {
              const percent = (slider.value / slider.max) * 100;
              label.textContent = slider.value;
              label.style.left = `${percent}%`;
              label.style.transform = 'translateX(-50%)';
            }

            function updateStartButton() {
              const heroesValid = selectedOrder.length >= 1 && selectedOrder.length <= 6;
              const overlordsValid = selectedOverlords.length >= 1 && selectedOverlords.length <= 3;
              const tacticsValid = selectedTactics.length >= 1 && selectedTactics.length <= 2;
              const enemiesValid = enemiesCount >= 15 && enemiesCount <= 50;
              const alliesValid = alliesCount >= 15 && alliesCount <= 50;

              if (heroesValid && overlordsValid && tacticsValid && enemiesValid && alliesValid) {
                startButton.classList.add('active');
                startButton.style.cursor = 'pointer';
              } else {
                startButton.classList.remove('active');
                startButton.style.cursor = 'not-allowed';
              }
            }

            // Sync slider ↔ number input
            function syncEnemyControls() {
              enemiesCount = Number(enemiesSlider.value);
              enemiesInput.value = enemiesCount;
              updateSliderLabel(enemiesSlider, enemiesValue);

              // Visual validation: red if invalid, green if valid
              if (enemiesCount < 15 || enemiesCount > 50) {
                enemiesSlider.style.accentColor = 'red';
              } else {
                enemiesSlider.style.accentColor = 'green';
              }

              updateStartButton();
            }

            function syncAllyControls() {
              alliesCount = Number(alliesSlider.value);
              alliesInput.value = alliesCount;
              updateSliderLabel(alliesSlider, alliesValue);

              // Visual validation: red if invalid, green if valid
              if (alliesCount < 15 || alliesCount > 50) {
                alliesSlider.style.accentColor = 'red';
              } else {
                alliesSlider.style.accentColor = 'green';
              }

              updateStartButton();
            }

            enemiesSlider.addEventListener('input', syncEnemyControls);
            enemiesInput.addEventListener('input', e => {
              let val = Math.max(0, Math.min(50, Number(e.target.value)));
              enemiesSlider.value = val;
              syncEnemyControls();
            });

            alliesSlider.addEventListener('input', syncAllyControls);
            alliesInput.addEventListener('input', e => {
              let val = Math.max(0, Math.min(50, Number(e.target.value)));
              alliesSlider.value = val;
              syncAllyControls();
            });

            // Randomize functions
            function randomizeEnemies() {
              enemiesUndoStack.push(enemiesCount);
              enemiesRedoStack = [];
              enemiesCount = Math.floor(Math.random() * 36) + 15; // 15–50
              enemiesSlider.value = enemiesCount;
              syncEnemyControls();
            }

            function randomizeAllies() {
              alliesUndoStack.push(alliesCount);
              alliesRedoStack = [];
              alliesCount = Math.floor(Math.random() * 36) + 15;
              alliesSlider.value = alliesCount;
              syncAllyControls();
            }

            document.getElementById('random-enemies').addEventListener('click', () => {
              randomizeEnemies();
              randomizeAllies();
            });

            document.getElementById('undo-enemies').addEventListener('click', () => {
              if (enemiesUndoStack.length > 0) {
                enemiesRedoStack.push(enemiesCount);
                enemiesCount = enemiesUndoStack.pop();
                enemiesSlider.value = enemiesCount;
                syncEnemyControls();
              }
              if (alliesUndoStack.length > 0) {
                alliesRedoStack.push(alliesCount);
                alliesCount = alliesUndoStack.pop();
                alliesSlider.value = alliesCount;
                syncAllyControls();
              }
            });

            document.getElementById('redo-enemies').addEventListener('click', () => {
              if (enemiesRedoStack.length > 0) {
                enemiesUndoStack.push(enemiesCount);
                enemiesCount = enemiesRedoStack.pop();
                enemiesSlider.value = enemiesCount;
                syncEnemyControls();
              }
              if (alliesRedoStack.length > 0) {
                alliesUndoStack.push(alliesCount);
                alliesCount = alliesRedoStack.pop();
                alliesSlider.value = alliesCount;
                syncAllyControls();
              }
            });

            // Include in export/import
            function exportLoadout() {
              const data = {
                heroes: selectedOrder,
                overlords: selectedOverlords,
                tactics: selectedTactics,
                enemies: enemiesCount,
                allies: alliesCount
              };
              const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
              const url = URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              a.download = 'loadout.json';
              a.click();
              URL.revokeObjectURL(url);
            }

            // --- Import loadout from user file (Unified) ---
            function importLoadout(event) {
              const file = event.target.files[0];
              if (!file) return;

              const reader = new FileReader();
              reader.onload = e => {
                try {
                  const data = JSON.parse(e.target.result);

                  // --- HEROES ---
                  if (Array.isArray(data.heroes)) {
                    selectedOrder = data.heroes.slice(0, 6);
                    updateBadges();
                  }

                  // --- OVERLORDS ---
                  if (Array.isArray(data.overlords)) {
                    selectedOverlords = data.overlords.slice(0, 3);
                    updateOverlordBadges();
                  }

                  // --- TACTICS ---
                  if (Array.isArray(data.tactics)) {
                    selectedTactics = data.tactics.slice(0, 2);
                    updateTacticStyles();
                  }

                  // --- ENEMIES ---
                  if (typeof data.enemies === 'number') {
                    enemiesCount = Math.min(50, Math.max(0, data.enemies));
                    enemiesSlider.value = enemiesCount;
                    syncEnemyControls();
                  }

                  // --- ALLIES ---
                  if (typeof data.allies === 'number') {
                    alliesCount = Math.min(50, Math.max(0, data.allies));
                    alliesSlider.value = alliesCount;
                    syncAllyControls();
                  }

                  updateStartButton();
                } catch (err) {
                  console.error('Failed to import loadout:', err);
                  alert('Invalid file format. Please use a valid .json loadout file.');
                }
              };

              reader.readAsText(file);
            }

            const limits = {
              heroes: { min: 1, max: 6 },
              overlords: { min: 1, max: 3 },
              tactics: { min: 1, max: 2 }
            };

            function topRandom() {
              if (selectedOrder.length < limits.heroes.min) randomizeSelection();
              if (selectedOverlords.length < limits.overlords.min) randomizeOverlords();
              if (selectedTactics.length < limits.tactics.min) randomizeTactics();
              if (enemiesCount < 15) randomizeEnemies();
              if (alliesCount < 15) randomizeAllies();

              updateBadges();
              updateOverlordBadges();
              updateTacticStyles();
              updateStartButton();
            }
            document.getElementById('top-random').addEventListener('click', topRandom);
        </script>
    </body>
</html>