<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover">
  <link href='https://fonts.googleapis.com/css?family=Racing Sans One' rel='stylesheet'>
  <link rel="icon" href="https://raw.githubusercontent.com/over-lords/overlords/4c614c1ffe5a9d7194202bd24fae5e7c99d86333/Public/Images/Site%20Assets/favicon.png" type="image/png">
  <link rel="stylesheet" href="style.css">
  <title>Overlords</title>
  <style>
  .hero-box {
  background-color: rgba(255, 255, 255, 0.9);
  border: none;                  /* remove inner border so it blends into dropdown */
  border-radius: 0 0 6px 6px;    /* keep rounded bottom to match dropdown */
  margin: 0;                     /* remove outside margins */
  padding: 15px;
  width: 100%;                   /* fill full dropdown width */
  box-sizing: border-box;        /* include padding in total width */
}
.hero-controls {
  display: flex;
  justify-content: center;
  gap: 15px;
  margin-bottom: 15px;
}
.hero-controls button {
  background-color: yellow;
  border: 2px solid black;
  border-radius: 4px;
  font-weight: bold;
  padding: 5px 12px;
  cursor: pointer;
}

.top-row {
  width: 95%;
  max-width: 1200px;
  margin: 10px auto 20px auto;
  display: flex;
  align-items: center;
  justify-content: space-between;
  position: relative;
}

.import-btn {
  background-color: yellow;
  border: 2px solid black;
  border-radius: 4px;
  font-weight: bold;
  padding: 6px 12px;
  cursor: pointer;
  position: absolute;
  left: 0;
}

.top-random-btn {
  background-color: yellow;
  border: 2px solid black;
  border-radius: 4px;
  font-weight: bold;
  padding: 6px 12px;
  cursor: pointer;
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
}

/* --- BOTTOM ROW --- */
.bottom-row {
  width: 95%;
  max-width: 1200px;
  margin: 25px auto 40px auto;
  display: flex;
  align-items: center;
  justify-content: space-between;
  position: relative;
}

.start-button {
  background-color: gray;
  border: 3px solid black;
  border-radius: 6px;
  color: black;
  font-weight: bold;
  font-size: 1.2rem;
  width: 250px;
  text-align: center;
  padding: 10px;
  cursor: not-allowed;
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
}

.start-button.active {
  background-color: yellow;
  cursor: pointer;
}

.export-btn {
  background-color: yellow;
  border: 2px solid black;
  border-radius: 4px;
  font-weight: bold;
  padding: 8px 16px;
  cursor: pointer;
  position: absolute;
  right: 0;
}
  /* Category container – wraps heroes into responsive rows */
  .category-group {
    border: 2px solid black;
    border-radius: 6px;
    margin: 15px 0;
    padding: 10px;
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 15px;
  }
  .guardian-bg { background-color: rgba(173, 216, 230, 0.5); }  /* Light blue */
  .striker-bg  { background-color: rgba(255, 182, 193, 0.5); }  /* Light red */
  .tactician-bg{ background-color: rgba(255, 255, 153, 0.5); }  /* Light yellow */

  .hero-category-title {
    flex-basis: 100%;
    text-align: center;
    font-weight: bold;
    font-size: 1.3rem;
    margin-bottom: 5px;
    text-shadow: 0 0 3px white;
  }

  .hero-card {
    text-align: center;
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
  }

  .hero-card img {
    width: 100px;
    height: 100px;
    object-fit: cover;
    border: 2px solid black;
    border-radius: 4px;
  }

  .hero-card.selected img {
    box-shadow: 0 0 10px 5px yellow;
    transform: scale(1.05);
  }

  .hero-card p {
    margin-top: 5px;
    font-weight: bold;
    font-size: 0.9rem;
  }

  .container {
    display: flex;
    flex-direction: column;
    align-items: center;
    }
  .collapsible {
  background-color: #5d5d5d;
  color: white;
  cursor: pointer;
  padding: 10px;
  width: 95%;
  max-width: 1200px;
  border: 2px solid black;
  border-radius: 6px;
  text-align: center;
  margin: 20px auto 0 auto;
  font-weight: bold;
  transition: border-radius 0.2s ease, border-bottom 0.2s ease;
  box-sizing: border-box;
}

.collapsible.active {
  background-color: #777;
  border-bottom: none;
  border-radius: 6px 6px 0 0;
}

.content {
  display: none;
  overflow: hidden;
  width: 95%;
  max-width: 1200px;
  margin: 0 auto;
  border: 2px solid black;
  border-top: none;             /* merge with open button border */
  border-radius: 0 0 6px 6px;
  box-sizing: border-box;       /* ensures exact same width */
}

.content.show {
  display: block;
}

  .start-button {
    background-color: gray;
    border: 3px solid black;
    border-radius: 6px;
    color: black;
    font-weight: bold;
    font-size: 1.2rem;
    width: 250px;
    text-align: center;
    margin: 20px auto;
    padding: 10px;
    cursor: not-allowed;
  }

  .start-button.active {
    background-color: yellow;
    cursor: pointer;
  }
  .boxed {
    display: inline-block;
    border: 3px solid black;
    background-color: rgba(255, 255, 255, 0.9);
    padding: 6px 10px;
    border-radius: 4px;
  }
  .hero-card { position: relative; }
.selection-badge {
  position: absolute;
  top: -6px;
  right: -6px;
  width: 26px;
  height: 26px;
  border-radius: 50%;
  background: yellow;
  border: 2px solid black;
  color: black;
  font-weight: 800;
  display: none;
  align-items: center;
  justify-content: center;
  font-size: 14px;
}
.hero-image-wrapper {
  position: relative;
  display: inline-block;  /* keeps wrapper tight to image */
}

.overlord-card {
  text-align: center;
  cursor: pointer;
  transition: transform 0.2s, box-shadow 0.2s;
  position: relative;
}

.overlord-card img {
  width: 100px;
  height: 100px;
  object-fit: cover;
  border: 2px solid black;
  border-radius: 6px;
}
.overlord-card.selected img {
  box-shadow: 0 0 12px 6px yellow;
  transform: scale(1.05);
}
.overlord-card p {
  margin: 5px 0;
  font-weight: bold;
}
.difficulty-1 {
  background-color: rgba(0, 255, 0, 0.2);
}
.difficulty-2 {
  background-color: rgba(255, 255, 0, 0.2);
}
.difficulty-3 {
  background-color: rgba(255, 0, 0, 0.2);
}
.difficulty-title {
  flex-basis: 100%;
  font-weight: bold;
  margin-top: 10px;
  text-align: center;
}
#tactics-grid {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 10px;
  margin-top: 10px;
}

.tactic-card {
  background-color: white;
  border: 2px solid black;
  border-radius: 12px;
  padding: 10px 15px;
  width: 80%;
  cursor: pointer;
  transition: transform 0.2s, box-shadow 0.2s;
  text-align: left;
  box-sizing: border-box;
}

.tactic-card:hover {
  transform: scale(1.02);
  box-shadow: 0 0 6px rgba(0,0,0,0.3);
}

.tactic-card.selected {
  box-shadow: 0 0 10px 4px yellow;
}

.tactic-card h3 {
  margin: 0;
  font-size: 1rem;
  font-weight: bold;
}

.tactic-card p {
  margin: 5px 0 0 0;
  font-size: 0.9rem;
}

.henchmen-section {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 100%;
}

.henchmen-section .collapsible {
  width: 100%;
  max-width: 900px; /* match the villain section width */
  box-sizing: border-box;
}

.henchmen-section .content {
  width: 100%;
  max-width: 900px;
  box-sizing: border-box;
}

/* Power 1 → pale green */
#henchmen-section > .henchmen-section:nth-of-type(2) > .collapsible { background-color:#ccffcc; color:black; }
/* Power 2 → pale yellow */
#henchmen-section > .henchmen-section:nth-of-type(3) > .collapsible { background-color:#fff7cc; color:black; }
/* Power 3 → pale red */
#henchmen-section > .henchmen-section:nth-of-type(4) > .collapsible { background-color:#ffcccc; color:black; }

#henchmen-section > .henchmen-section:nth-of-type(2) > .content { background-color:#f6fff6; }
#henchmen-section > .henchmen-section:nth-of-type(3) > .content { background-color:#fffdf2; }
#henchmen-section > .henchmen-section:nth-of-type(4) > .content { background-color:#fff5f5; }

#henchmen-grid-1,
#henchmen-grid-2,
#henchmen-grid-3 {
  border: none !important;
  background: none !important;
  border-radius: 0 !important;
  padding: 0 !important;
  margin: 0 !important;   /* kills the extra gap made by .category-group */
}

img {
  object-position: 50% 25%; /* 50% = center horizontally, 25% = crop 25% closer to top */
}

/* === Collapsible arrow styles === */
.collapsible::after {
  content: "▼";
  float: right;
  transition: transform 0.2s ease;
  font-weight: bold;
}
.collapsible.active::after {
  content: "▲";
}

/* ===== Villain collapsible arrows (on the left) ===== */
.villain-collapsible {
  display: flex;
  align-items: center;
  gap: 6px;
  justify-content: flex-start;
  width: 100%;
  box-sizing: border-box;
  padding-left: 10px;
}

.villain-collapsible::before {
  content: "▼";
  font-weight: bold;
  margin-right: 6px;
  transition: transform 0.2s ease;
}

.villain-collapsible.active::before {
  content: "▲";
}

/* override the generic right-side arrow for villains */
.villain-collapsible::after {
  content: none !important;
}

</style>
</head>
    <body style="background-color:white;" onload="window.scrollTo(0, 1)">
        <div class="bg-image" alt="" style="opacity: 35%;"></div>
        <div class="container">
            <div class="title-box" id="title-box"></div>
            <h1 class="glow-red" style="pointer-events: none;">Overlords</h1>

            <div id="close-box" onclick="location.href='play.html'">X</div>

            <div class="container" style="margin-top: 110px; width: 100%;">
                <p class="boxed" style="font-weight: bold; font-family: 'Poppins', sans-serif;">Design your Singleplayer game!</p>
                <div class="top-row">
                  <button id="import-loadout" class="import-btn">Import Loadout</button>
                  <button id="top-random" class="top-random-btn">Random</button>
                </div>
                <button class="collapsible" style="background-color: lightgreen; color: black;">Select Your Heroes (1-6)</button>
                <div class="content">
                <div class="hero-box">
                  <div class="hero-controls">
                    <button id="undo-random">Undo</button>
                    <button id="random-heroes">Random</button>
                    <button id="redo-random">Redo</button>
                  </div>
                    <div id="hero-grid" class="hero-grid"></div>
                </div>
                </div>

                <button class="collapsible" style="background-color: lightcoral; color: black;">Select Your Overlords (1-3)</button>
                <div class="content">
                  <div class="hero-box">
                    <div class="hero-controls">
                      <button id="undo-overlords">Undo</button>
                      <button id="random-overlords">Random</button>
                      <button id="redo-overlords">Redo</button>
                    </div>
                    <div id="overlord-grid" class="hero-grid"></div>
                  </div>
                </div>

                <button class="collapsible" style="background-color: lightskyblue; color: black;">Select Your Tactics (1-2)</button>
                <div class="content">
                  <div class="hero-box">
                    <div class="hero-controls">
                      <button id="undo-tactics">Undo</button>
                      <button id="random-tactics">Random</button>
                      <button id="redo-tactics">Redo</button>
                    </div>
                    <div id="tactics-grid" class="hero-grid"></div>
                  </div>
                </div>

                <button class="collapsible" style="background-color: rgb(235, 36, 235); color: black;">Enemies and Allies (15–50 each)</button>
                <div class="content">
                  <div class="hero-box">
                    <p style="font-weight:bold; margin-bottom:25px;">
                      Recommended 30 each for a total of 60
                    </p>

                    <div style="display:flex; flex-direction:column; gap:20px; align-items:center;">

                      <!-- ENEMIES SLIDER -->
                      <div style="display:flex; align-items:center; gap:10px; width:90%; max-width:600px;">
                        <label style="width:50px; text-align:right;">Enemies</label>
                        <div style="position:relative; flex:1;">
                          <input id="enemies-slider" type="range" min="0" max="50" value="0" step="1"
                                style="width:100%; cursor:pointer;">
                          <div id="enemies-value"
                              style="position:absolute; top:-15px; left:0; transform:translateX(0%);
                                      font-weight:bold; text-align:center;">0</div>
                        </div>
                        <label style="width:20px; text-align:center;"></label>
                        <input id="enemies-input" type="number" min="0" max="50" value="0"
                              style="width:60px; text-align:center;">
                      </div>

                      <!-- ALLIES SLIDER -->
                      <div style="display:flex; align-items:center; gap:10px; width:90%; max-width:600px;">
                        <label style="width:50px; text-align:right;">Allies</label>
                        <div style="position:relative; flex:1;">
                          <input id="allies-slider" type="range" min="0" max="50" value="0" step="1"
                                style="width:100%; cursor:pointer;">
                          <div id="allies-value"
                              style="position:absolute; top:-15px; left:0; transform:translateX(0%);
                                      font-weight:bold; text-align:center;">0</div>
                        </div>
                        <label style="width:20px; text-align:center;"></label>
                        <input id="allies-input" type="number" min="0" max="50" value="0"
                              style="width:60px; text-align:center;">
                      </div>

                      <div class="hero-controls">
                        <button id="undo-enemies">Undo</button>
                        <button id="random-enemies">Random</button>
                        <button id="redo-enemies">Redo</button>
                      </div>
                    </div>
                  </div>
                </div>

                <button class="collapsible" style="background-color: rgb(255, 85, 85); color: black;">Villain Deck (60–140)</button>
                <div class="content" id="villain-deck">
                  <div class="hero-box">
                    <p style="font-weight:bold;margin-bottom:12px;">Villain Deck (60-140) — Recommended 90 total</p>

                    <!-- Mights of the Overlord -->
                    <div style="display:flex; align-items:center; gap:10px; width:90%; max-width:700px; margin:10px auto;">
                      <label style="width:170px; text-align:right;">Mights (3–10)</label>
                      <div style="position:relative; flex:1;">
                        <input id="mights-slider" type="range" min="0" max="10" value="0" step="1" style="width:100%;">
                        <div id="mights-value" style="position:absolute; top:-15px; left:0; font-weight:bold; transform:translateX(-50%);">8</div>
                      </div>
                      <span style="font-size:.9rem;">Recommended: 8</span>
                      <input id="mights-input" type="number" min="0" max="10" value="0" style="width:60px; text-align:center;">
                    </div>

                    <!-- Bystanders -->
                    <div style="display:flex; align-items:center; gap:10px; width:90%; max-width:700px; margin:10px auto;">
                      <label style="width:170px; text-align:right;">Bystanders (7–15)</label>
                      <div style="position:relative; flex:1;">
                        <input id="bystanders-slider" type="range" min="0" max="15" value="0" step="1" style="width:100%;">
                        <div id="bystanders-value" style="position:absolute; top:-15px; left:0; font-weight:bold; transform:translateX(-50%);">10</div>
                      </div>
                      <span style="font-size:.9rem;">Recommended: 10</span>
                      <input id="bystanders-input" type="number" min="0" max="15" value="0" style="width:60px; text-align:center;">
                    </div>

                    <!-- Bystander breakdown (auto-filled distribution) -->
                    <div id="bystanders-breakdown" style="width:90%; max-width:700px; margin:6px auto 14px auto; font-size:0rem; color: transparent;"></div>

                    <!-- Scenarios (0–5) -->
                    <div style="margin-top:16px;">
                      <div style="font-weight:bold; margin-bottom:6px;">Scenarios (0–5) — Recommended 2</div>
                      <div class="hero-controls">
                        <button id="undo-scenarios">Undo</button>
                        <button id="random-scenarios">Random</button>
                        <button id="redo-scenarios">Redo</button>
                      </div>
                      <div id="scenarios-grid" style="display:flex; flex-direction:column; gap:10px; align-items:center;"></div>
                    </div>

                    <!-- Henchmen (20–40) -->
                    <div style="margin-top:16px;">
                      <div style="font-weight:bold; margin-bottom:6px;">Henchmen (20–40) — Recommended 30</div>
                      <div id="henchmen-section">
                        <div style="display:flex; gap:10px; align-items:center; justify-content:space-between;">
                          <div><button id="henchmen-deselect-all" style="
                              background-color: yellow;
                              border: 2px solid black;
                              border-radius: 4px;
                              font-weight: bold;
                              padding: 5px 12px;
                              cursor: pointer;">Deselect All</button></div>
                          <div class="hero-controls">
                            <button id="undo-henchmen">Undo</button>
                            <button id="random-henchmen">Random</button>
                            <button id="redo-henchmen">Redo</button>
                          </div>
                        </div>

                        <div class="henchmen-section">
                          <button class="collapsible">Henchmen — Power 1</button>
                          <div class="content">
                            <div id="henchmen-grid-1" class="category-group"></div>
                          </div>
                        </div>

                        <div class="henchmen-section">
                          <button class="collapsible">Henchmen — Power 2</button>
                          <div class="content">
                            <div id="henchmen-grid-2" class="category-group"></div>
                          </div>
                        </div>

                        <div class="henchmen-section">
                          <button class="collapsible">Henchmen — Power 3</button>
                          <div class="content">
                            <div id="henchmen-grid-3" class="category-group"></div>
                          </div>
                        </div>
                      </div>
                      <div id="henchmen-total" style="text-align:right; font-weight:bold; margin-top:6px;">Total: 0</div>
                    </div>

                    <!-- Villains (30–70) -->
                    <div style="margin-top:16px;">
                      <div style="font-weight:bold; margin-bottom:6px;">Villains (30–70) — Recommended 40</div>

                      <div style="display:flex; gap:10px; align-items:center; justify-content:space-between;">
                        <div><button id="villains-deselect-all" style="
                              background-color: yellow;
                              border: 2px solid black;
                              border-radius: 4px;
                              font-weight: bold;
                              padding: 5px 12px;
                              cursor: pointer;">Deselect All</button></div>
                        <div class="hero-controls">
                          <button id="undo-villains">Undo</button>
                          <button id="random-villains">Random</button>
                          <button id="redo-villains">Redo</button>
                        </div>
                      </div>

                      <div id="villains-groups"></div>
                      <div id="villains-total" style="text-align:right; font-weight:bold; margin-top:6px;">Total: 0</div>
                    </div>

                    <!-- Villain Deck total indicator -->
                    <div id="villain-deck-total" style="margin-top:14px; text-align:right; font-weight:bold;">Deck Total: 0</div>
                  </div>
                </div>

                <br>
                <div class="bottom-row">
                  <button id="start-button" class="start-button">Start Game!</button>
                  <button id="export-loadout" class="export-btn">Export Loadout</button>
                </div>
                <br><br><br>
            </div>
        </div>

        <script type="module">
            import { heroes } from './data/faceCards.js';
            import { overlords } from './data/overlords.js';
            import { tactics } from './data/tactics.js';
            import { enemies } from './data/enemies.js';
            import { allies } from './data/allies.js';
            import { bystanders } from './data/bystanders.js';
            import { scenarios } from './data/scenarios.js';
            import { henchmen } from './data/henchmen.js';
            import { villains } from './data/villains.js';
            import { renderAbilityText } from './utils/cardRenderer.js';

            const collapsible = document.querySelector('.collapsible');
            const content = document.querySelector('.content');

            const heroGrid = document.getElementById('hero-grid');
            const startButton = document.getElementById('start-button');

            document.querySelectorAll('.collapsible').forEach(button => {
              button.addEventListener('click', () => {
                button.classList.toggle('active');
                const content = button.nextElementSibling;
                if (content) content.classList.toggle('show');
              });
            });

            // Sort and filter heroes
            const filteredHeroes = heroes
                .filter(h => h.doNotShow !== "true")
                .sort((a, b) => {
                const order = { Guardian: 1, Striker: 2, Tactician: 3 };
                if (order[a.category] !== order[b.category]) return order[a.category] - order[b.category];
                return parseInt(a.id) - parseInt(b.id);
                });

            const categories = [
                { name: 'Guardian', class: 'guardian-bg' },
                { name: 'Striker', class: 'striker-bg' },
                { name: 'Tactician', class: 'tactician-bg' }
            ];

            // Render categories with wrapping grids
            categories.forEach(cat => {
                const catHeroes = filteredHeroes.filter(h => h.category === cat.name);
                if (!catHeroes.length) return;

                const section = document.createElement('div');
                section.classList.add('category-group', cat.class);

                const title = document.createElement('div');
                title.classList.add('hero-category-title');

                // Count only heroes that are not doNotShow:true
                const visibleCount = catHeroes.filter(h => h.doNotShow !== "true").length;

                // Add an 's' for pluralized category names
                title.textContent = `${cat.name}s (${visibleCount})`;

                section.appendChild(title);

                catHeroes.forEach(hero => {
                const card = document.createElement('div');
                card.classList.add('hero-card');
                card.dataset.id = hero.id;

                const img = document.createElement('img');
                img.src = hero.image;
                img.alt = hero.name;

                const name = document.createElement('p');
                name.textContent = hero.name;

                const badge = document.createElement('span');
                badge.className = 'selection-badge';
                badge.textContent = '';

                const wrapper = document.createElement('div');
                wrapper.className = 'hero-image-wrapper';
                wrapper.appendChild(img);
                wrapper.appendChild(badge);

                card.appendChild(wrapper);
                card.appendChild(name);
                section.appendChild(card);
                });

                heroGrid.appendChild(section);
            });

            // Keep ordered selection
            let selectedOrder = [];

            // Paint all badges and selected styles based on selectedOrder
            function updateBadges() {
              document.querySelectorAll('.hero-card').forEach(card => {
                const id = card.dataset.id;
                const idx = selectedOrder.indexOf(id);
                const badge = card.querySelector('.selection-badge');

                if (idx > -1) {
                  card.classList.add('selected');
                  if (badge) {
                    badge.style.display = 'flex';
                    badge.textContent = String(idx + 1);
                  }
                } else {
                  card.classList.remove('selected');
                  if (badge) {
                    badge.style.display = 'none';
                    badge.textContent = '';
                  }
                }
              });
            }

            heroGrid.addEventListener('click', e => {
              const card = e.target.closest('.hero-card');
              if (!card) return;

              const heroId = card.dataset.id;
              const idx = selectedOrder.indexOf(heroId);

              if (idx > -1) {
                // Deselect: remove and reindex others
                selectedOrder.splice(idx, 1);
              } else if (selectedOrder.length < 6) {
                // Select: append to the end; order matters
                selectedOrder.push(heroId);
              }

              updateBadges();
              updateStartButton();
            });

            // Encrypt data using AES-GCM with SHA-256–derived key
            async function encryptData(data, secretKey) {
              const enc = new TextEncoder();
              const iv = crypto.getRandomValues(new Uint8Array(12));

              // Derive a 256-bit key from any secret string
              const keyMaterial = await crypto.subtle.digest("SHA-256", enc.encode(secretKey));
              const key = await crypto.subtle.importKey(
                "raw",
                keyMaterial,
                { name: "AES-GCM" },
                false,
                ["encrypt"]
              );

              const encoded = enc.encode(JSON.stringify(data));
              const cipherBuffer = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, encoded);

              // Combine IV + ciphertext → base64
              const combined = new Uint8Array(iv.length + cipherBuffer.byteLength);
              combined.set(iv);
              combined.set(new Uint8Array(cipherBuffer), iv.length);
              return btoa(String.fromCharCode(...combined));
            }

            startButton.addEventListener("click", async () => {
              if (!startButton.classList.contains("active")) return;

              const SECRET = "GeimonHeroKey42";
              const payload = {
                heroes: selectedOrder,
                overlords: selectedOverlords,
                tactics: selectedTactics,
                enemies: { count: enemiesCount, ids: selectedEnemies },
                allies: { count: alliesCount, ids: selectedAllies },
                villainDeck: {
                  mights: mightsCount,
                  bystanders: {
                    count: bystandersCount,
                    byType: bystandersByType
                  },
                  scenarios: selectedScenarios, // ids
                  henchmen: Array.from(henchmenCounts.entries()).map(([id,count]) => ({id, count})),
                  villains: Array.from(selectedVillains) // ids
                }
              };

              const encrypted = await encryptData(payload, SECRET);
              const url = new URL("./game.html", window.location.href);
              url.searchParams.set("data", encrypted);
              window.location.href = url.toString();
            });

            // --- Randomization and Loadout Management ---
            let undoStack = [];
            let redoStack = [];

            // Utility: get all hero IDs not yet chosen
            function getUnselectedHeroes() {
              const allIds = Array.from(document.querySelectorAll('.hero-card')).map(c => c.dataset.id);
              return allIds.filter(id => !selectedOrder.includes(id));
            }

            // Utility: apply selected order visually
            function applySelection(order) {
              selectedOrder = order.slice();
              updateBadges();
              updateStartButton();
            }

            // Randomly fill remaining slots up to 6
            function randomizeSelection() {
              const maxSelectable = 6 - selectedOrder.length;
              if (maxSelectable <= 0) return;

              const available = getUnselectedHeroes();
              if (available.length === 0) return;

              // Choose a random number of new heroes between 1 and maxSelectable
              const countToAdd = Math.floor(Math.random() * maxSelectable) + 1;
              const toAdd = [];

              while (toAdd.length < countToAdd && available.length > 0) {
                const idx = Math.floor(Math.random() * available.length);
                toAdd.push(available.splice(idx, 1)[0]);
              }

              undoStack.push([...selectedOrder]);  // save pre-random state
              redoStack = [];                      // clear redo on new random
              selectedOrder = [...selectedOrder, ...toAdd];

              updateBadges();
              updateStartButton();
            }

            // Undo last random
            function undoRandom() {
              if (undoStack.length === 0) return;
              redoStack.push([...selectedOrder]);
              const prev = undoStack.pop();
              applySelection(prev);
            }

            // Redo last undone random
            function redoRandom() {
              if (redoStack.length === 0) return;
              undoStack.push([...selectedOrder]);
              const next = redoStack.pop();
              applySelection(next);
            }

            // --- Button bindings ---
            document.getElementById('random-heroes').addEventListener('click', randomizeSelection);
            document.getElementById('undo-random').addEventListener('click', undoRandom);
            document.getElementById('redo-random').addEventListener('click', redoRandom);
            document.getElementById('export-loadout').addEventListener('click', exportLoadout);

            // Create hidden file input for import
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.txt';
            fileInput.style.display = 'none';
            fileInput.addEventListener('change', importLoadout);
            document.body.appendChild(fileInput);

            document.getElementById('import-loadout').addEventListener('click', () => fileInput.click());

            // ==================== OVERLORD SECTION ====================
            const overlordGrid = document.getElementById('overlord-grid');
            let selectedOverlords = [];
            let overlordUndoStack = [];
            let overlordRedoStack = [];

            // Filter and group Overlords
            const filteredOverlords = overlords
              .filter(o => String(o.doNotShow).toLowerCase() !== "true")
              .map(o => ({
                ...o,
                level: Number(o.level),
                hp: Number(o.hp)
              }))
              .sort((a, b) => a.level - b.level || a.hp - b.hp);

            // Group by difficulty
            const difficulties = [
              { level: 1, colorClass: 'difficulty-1', label: 'Easy' },
              { level: 2, colorClass: 'difficulty-2', label: 'Medium' },
              { level: 3, colorClass: 'difficulty-3', label: 'Hard' }
            ];

            difficulties.forEach(diff => {
              const section = document.createElement('div');
              section.classList.add('category-group', diff.colorClass);

              const title = document.createElement('div');
              title.classList.add('difficulty-title');
              title.textContent = `Difficulty ${diff.level} (${diff.label})`;
              section.appendChild(title);

              const overlordGroup = filteredOverlords.filter(o => o.level === diff.level);
              overlordGroup.forEach(overlord => {
                const card = document.createElement('div');
                card.classList.add('overlord-card');
                card.dataset.id = overlord.id;
                card.dataset.level = overlord.level;
                card.dataset.hp = overlord.hp;

                const img = document.createElement('img');
                img.src = overlord.image;
                img.alt = overlord.name;

                const name = document.createElement('p');
                name.textContent = overlord.name;

                const hp = document.createElement('p');
                hp.textContent = `${overlord.hp} HP`;

                const badge = document.createElement('span');
                badge.className = 'selection-badge';

                const wrapper = document.createElement('div');
                wrapper.className = 'hero-image-wrapper';
                wrapper.appendChild(img);
                wrapper.appendChild(badge);

                card.appendChild(wrapper);
                card.appendChild(name);
                card.appendChild(hp);
                section.appendChild(card);
              });

              overlordGrid.appendChild(section);
            });

            // Update visuals
            function updateOverlordBadges() {
              document.querySelectorAll('.overlord-card').forEach(card => {
                const id = card.dataset.id;
                const idx = selectedOverlords.indexOf(id);
                const badge = card.querySelector('.selection-badge');

                if (idx > -1) {
                  card.classList.add('selected');
                  if (badge) {
                    badge.style.display = 'flex';
                    badge.textContent = String(idx + 1);
                  }
                } else {
                  card.classList.remove('selected');
                  if (badge) {
                    badge.style.display = 'none';
                    badge.textContent = '';
                  }
                }
              });
            }

            // Handle click
            overlordGrid.addEventListener('click', e => {
              const card = e.target.closest('.overlord-card');
              if (!card) return;
              const id = card.dataset.id;
              const idx = selectedOverlords.indexOf(id);

              if (idx > -1) {
                selectedOverlords.splice(idx, 1);
              } else if (selectedOverlords.length < 3) {
                selectedOverlords.push(id);
              }

              // Sort by difficulty, then HP
              const overlordData = overlords.filter(o => selectedOverlords.includes(String(o.id)));
              overlordData.sort((a, b) => a.level - b.level || a.hp - b.hp);
              selectedOverlords = overlordData.map(o => String(o.id));

              updateOverlordBadges();
              updateStartButton();
            });

            // Randomize Overlords
            function randomizeOverlords() {
              const maxSelectable = 3 - selectedOverlords.length;
              if (maxSelectable <= 0) return;

              const available = filteredOverlords
                .filter(o => !selectedOverlords.includes(String(o.id)));
              if (available.length === 0) return;

              const countToAdd = Math.max(1, Math.ceil(Math.random() * maxSelectable));
              const toAdd = [];

              while (toAdd.length < countToAdd && available.length > 0) {
                const idx = Math.floor(Math.random() * available.length);
                toAdd.push(available.splice(idx, 1)[0]);
              }

              overlordUndoStack.push([...selectedOverlords]);
              overlordRedoStack = [];

              const newSelection = [...selectedOverlords, ...toAdd.map(o => String(o.id))];
              const ordered = overlords
                .filter(o => newSelection.includes(String(o.id)))
                .sort((a, b) => a.level - b.level || a.hp - b.hp);
              selectedOverlords = ordered.map(o => String(o.id));

              updateOverlordBadges();
              updateStartButton();
            }

            function undoOverlords() {
              if (overlordUndoStack.length === 0) return;
              overlordRedoStack.push([...selectedOverlords]);
              selectedOverlords = overlordUndoStack.pop();
              updateOverlordBadges();
              updateStartButton();
            }

            function redoOverlords() {
              if (overlordRedoStack.length === 0) return;
              overlordUndoStack.push([...selectedOverlords]);
              selectedOverlords = overlordRedoStack.pop();
              updateOverlordBadges();
              updateStartButton();
            }

            // Button bindings
            document.getElementById('random-overlords').addEventListener('click', randomizeOverlords);
            document.getElementById('undo-overlords').addEventListener('click', undoOverlords);
            document.getElementById('redo-overlords').addEventListener('click', redoOverlords);

            // ==================== TACTICS SECTION ====================
            const tacticsGrid = document.getElementById('tactics-grid');
            let selectedTactics = [];
            let tacticsUndoStack = [];
            let tacticsRedoStack = [];

            // Filter and sort tactics alphabetically, ignoring doNotShow:true
            const filteredTactics = tactics
              .filter(t => String(t.doNotShow).toLowerCase() !== "true")
              .sort((a, b) => a.name.localeCompare(b.name));

            // Render tactics
            filteredTactics.forEach(t => {
              const card = document.createElement('div');
              card.classList.add('tactic-card');
              card.dataset.id = t.id;

              const title = document.createElement('h3');
              title.textContent = t.name;

              const desc = document.createElement('div');
              const rawText = Array.isArray(t.abilitiesText)
                ? t.abilitiesText.map(a => a.text).join('<br><br>')
                : 'No effect listed.';
              desc.innerHTML = renderAbilityText(rawText);
              desc.style.fontSize = '0.9rem';
              desc.style.marginTop = '5px';
              desc.style.lineHeight = '1.25em';
              desc.style.textAlign = 'left';

              card.appendChild(title);
              card.appendChild(desc);
              tacticsGrid.appendChild(card);
            });

            // Update visuals
            function updateTacticStyles() {
              document.querySelectorAll('.tactic-card').forEach(card => {
                const id = card.dataset.id;
                if (selectedTactics.includes(id)) {
                  card.classList.add('selected');
                } else {
                  card.classList.remove('selected');
                }
              });
            }

            // Handle click selection
            tacticsGrid.addEventListener('click', e => {
              const card = e.target.closest('.tactic-card');
              if (!card) return;
              const id = card.dataset.id;
              const idx = selectedTactics.indexOf(id);

              if (idx > -1) {
                selectedTactics.splice(idx, 1);
              } else if (selectedTactics.length < 2) {
                selectedTactics.push(id);
              }

              updateTacticStyles();
              updateStartButton();
            });

            // Randomize Tactics
            function randomizeTactics() {
              const maxSelectable = 2 - selectedTactics.length;
              if (maxSelectable <= 0) return;

              const available = filteredTactics.filter(t => !selectedTactics.includes(String(t.id)));
              if (available.length === 0) return;

              const countToAdd = Math.floor(Math.random() * maxSelectable) + 1;
              const toAdd = [];

              while (toAdd.length < countToAdd && available.length > 0) {
                const idx = Math.floor(Math.random() * available.length);
                toAdd.push(available.splice(idx, 1)[0]);
              }

              tacticsUndoStack.push([...selectedTactics]);
              tacticsRedoStack = [];

              selectedTactics = [...selectedTactics, ...toAdd.map(t => String(t.id))];
              updateTacticStyles();

              // --- Immediately fix enemy/allies sliders if new tactic has restrictions ---
              let enemiesOnly = false;
              let minEnemies = 15;
              for (const tacticId of selectedTactics) {
                const t = tactics.find(tt => String(tt.id) === String(tacticId));
                if (Array.isArray(t.limitEaA) && t.limitEaA[0] === "allEnemies") {
                  enemiesOnly = true;
                  const match = t.limitEaA[1].match(/\d+/);
                  minEnemies = match ? Number(match[0]) : 30;
                  break;
                }
              }
              if (enemiesOnly) {
                enemiesCount = Math.floor(Math.random() * (50 - minEnemies + 1)) + minEnemies;
                alliesCount = 0;
              }
              enemiesSlider.value = enemiesCount;
              alliesSlider.value = alliesCount;
              syncEnemyControls();
              syncAllyControls();

              updateStartButton();
            }


            function undoTactics() {
              if (tacticsUndoStack.length === 0) return;
              tacticsRedoStack.push([...selectedTactics]);
              selectedTactics = tacticsUndoStack.pop();
              updateTacticStyles();
              updateStartButton();
            }

            function redoTactics() {
              if (tacticsRedoStack.length === 0) return;
              tacticsUndoStack.push([...selectedTactics]);
              selectedTactics = tacticsRedoStack.pop();
              updateTacticStyles();
              updateStartButton();
            }

            // Add button bindings
            document.getElementById('random-tactics').addEventListener('click', randomizeTactics);
            document.getElementById('undo-tactics').addEventListener('click', undoTactics);
            document.getElementById('redo-tactics').addEventListener('click', redoTactics);

            // ==================== ENEMIES & ALLIES SECTION ====================
            const enemiesSlider = document.getElementById('enemies-slider');
            const alliesSlider = document.getElementById('allies-slider');
            const enemiesValue = document.getElementById('enemies-value');
            const alliesValue = document.getElementById('allies-value');
            const enemiesInput = document.getElementById('enemies-input');
            const alliesInput = document.getElementById('allies-input');

            let enemiesCount = 0;
            let alliesCount = 0;

            let enemiesUndoStack = [];
            let enemiesRedoStack = [];
            let alliesUndoStack = [];
            let alliesRedoStack = [];

            // Update the position label above each slider
            function updateSliderLabel(slider, label) {
              const percent = (slider.value / slider.max) * 100;
              label.textContent = slider.value;
              label.style.left = `${percent}%`;
              label.style.transform = 'translateX(-50%)';
            }

            function updateStartButton() {
              const startButton = document.getElementById("start-button");

              // --- Base conditions from earlier ---
              const hasHero = selectedOrder.length >= 1;
              const hasOverlord = selectedOverlords.length >= 1;
              const hasTactic = selectedTactics.length >= 1;

              // --- Reset per-update state ---
              let eaAValid = true;
              let tacticValid = true;
              let overlordValid = true;

              // read tactic restrictions
              let allEnemiesRestriction = false;
              let minEnemiesRequired = 15;
              let minAlliesRequired  = 15;
              let requiresMultiTactic = false;
              let requiresMultiOverlord = false;

              for (const tacticId of selectedTactics) {
                const tacticData = tactics.find(t => String(t.id) === String(tacticId));
                if (!tacticData) continue;
                if (Array.isArray(tacticData.limitEaA) && tacticData.limitEaA[0]==='allEnemies'){
                  allEnemiesRestriction = true;
                  const m = tacticData.limitEaA[1].match(/\d+/); if (m) minEnemiesRequired = Number(m[0]);
                  minAlliesRequired = 0;
                }
                if (tacticData.multiTacticReq === 'yes') requiresMultiTactic = true;
                if (tacticData.multiOverlordReq === 'yes') requiresMultiOverlord = true;
              }

              // --- Enemies/Allies validity ---
              if (allEnemiesRestriction){
                if (enemiesCount < minEnemiesRequired) eaAValid = false;
                if (alliesCount !== 0) eaAValid = false;
              } else {
                if (enemiesCount < 15 || enemiesCount > 50) eaAValid = false;
                if (alliesCount < 15 || alliesCount > 50) eaAValid = false;
              }

              if (requiresMultiTactic && selectedTactics.length < 2) tacticValid = false;
              if (requiresMultiOverlord && selectedOverlords.length < 2) overlordValid = false;

              // --- Villain Deck validations ---
              const henchTotal = Array.from(henchmenCounts.values()).reduce((a,b)=>a+(Number(b)||0),0);
              const villainsTotal = selectedVillains.size;

              const mightsValid = (mightsCount >= 3 && mightsCount <= 10);
              const bysValid    = (bystandersCount >= 7 && bystandersCount <= 15);
              const henchValid  = (henchTotal >= 20 && henchTotal <= 40);
              const villsValid  = (villainsTotal >= 30 && villainsTotal <= 70); //set min here to 1 for testing

              const deckTotal = mightsCount + bystandersCount + henchTotal + villainsTotal;
              deckTotalEl.textContent = `Deck Total: ${deckTotal}`;
              const deckTotalValid = (deckTotal >= 60 && deckTotal <= 140); //set min here to 1 for testing

              const villainDeckValid = mightsValid && bysValid && henchValid && villsValid && deckTotalValid;

              const canStart =
                hasHero && hasOverlord && hasTactic &&
                eaAValid && tacticValid && overlordValid &&
                villainDeckValid;

              startButton.disabled = !canStart;
              startButton.classList.toggle("active", canStart);
              startButton.style.opacity = canStart ? "1" : "0.5";

              // quick color feedback on sliders
              setAccent(mightsSlider, mightsValid);
              setAccent(bysSlider, bysValid);
              henchmenTotalEl.style.color = henchValid ? 'inherit' : 'red';
              villainsTotalEl.style.color = villsValid ? 'inherit' : 'red';
              deckTotalEl.style.color = deckTotalValid ? 'inherit' : 'red';
            }

            let selectedEnemies = [];
            let selectedAllies = [];

            // Sync slider ↔ number input
            function syncEnemyControls() {
              enemiesCount = Number(enemiesSlider.value);
              enemiesInput.value = enemiesCount;
              updateSliderLabel(enemiesSlider, enemiesValue);

              // --- Determine if any selected tactic sets allEnemies restriction ---
              let allEnemiesRestriction = false;
              for (const tacticId of selectedTactics) {
                const tacticData = tactics.find(t => String(t.id) === String(tacticId));
                if (Array.isArray(tacticData?.limitEaA) && tacticData.limitEaA[0] === "allEnemies") {
                  allEnemiesRestriction = true;
                  break;
                }
              }

              // Ensure selectedEnemies is populated even when manually changed
              if (selectedEnemies.length === 0 && enemies.length > 0) {
                const available = [...enemies];
                const chosen = [];
                while (chosen.length < enemiesCount && available.length > 0) {
                  const idx = Math.floor(Math.random() * available.length);
                  chosen.push(available.splice(idx, 1)[0].id);
                }
                selectedEnemies = chosen;
              }

              // --- Visual feedback ---
              if (allEnemiesRestriction) {
                // For "allEnemies" tactics
                if (enemiesCount < 30 || enemiesCount > 50) {
                  enemiesSlider.style.accentColor = 'red';
                } else {
                  enemiesSlider.style.accentColor = 'green';
                }
              } else {
                // Default mode
                if (enemiesCount < 15 || enemiesCount > 50) {
                  enemiesSlider.style.accentColor = 'red';
                } else {
                  enemiesSlider.style.accentColor = 'green';
                }
              }

              updateStartButton();
            }

            function syncAllyControls() {
              alliesCount = Number(alliesSlider.value);
              alliesInput.value = alliesCount;
              updateSliderLabel(alliesSlider, alliesValue);

              // --- Determine if any selected tactic sets allEnemies restriction ---
              let allEnemiesRestriction = false;
              for (const tacticId of selectedTactics) {
                const tacticData = tactics.find(t => String(t.id) === String(tacticId));
                if (Array.isArray(tacticData?.limitEaA) && tacticData.limitEaA[0] === "allEnemies") {
                  allEnemiesRestriction = true;
                  break;
                }
              }

              // Ensure selectedAllies is populated even when manually changed
              if (selectedAllies.length === 0 && allies.length > 0) {
                const available = [...allies];
                const chosen = [];
                while (chosen.length < alliesCount && available.length > 0) {
                  const idx = Math.floor(Math.random() * available.length);
                  chosen.push(available.splice(idx, 1)[0].id);
                }
                selectedAllies = chosen;
              }

              // --- Visual feedback ---
              if (allEnemiesRestriction) {
                // For "allEnemies" tactics
                if (alliesCount === 0) {
                  alliesSlider.style.accentColor = 'green';
                } else {
                  alliesSlider.style.accentColor = 'red';
                }
              } else {
                // Default mode
                if (alliesCount < 15 || alliesCount > 50) {
                  alliesSlider.style.accentColor = 'red';
                } else {
                  alliesSlider.style.accentColor = 'green';
                }
              }

              updateStartButton();
            }

            enemiesSlider.addEventListener('input', syncEnemyControls);
            enemiesInput.addEventListener('input', e => {
              let val = Math.max(0, Math.min(50, Number(e.target.value)));
              enemiesSlider.value = val;
              syncEnemyControls();
            });

            alliesSlider.addEventListener('input', syncAllyControls);
            alliesInput.addEventListener('input', e => {
              let val = Math.max(0, Math.min(50, Number(e.target.value)));
              alliesSlider.value = val;
              syncAllyControls();
            });

            // Randomize functions
            function randomizeEnemies() {
              enemiesUndoStack.push([...selectedEnemies]);
              enemiesRedoStack = [];

              enemiesCount = Math.floor(Math.random() * 36) + 15; // 15–50
              enemiesSlider.value = enemiesCount;

              // Randomly select N enemy IDs
              const available = [...enemies];
              const chosen = [];
              while (chosen.length < enemiesCount && available.length > 0) {
                const idx = Math.floor(Math.random() * available.length);
                chosen.push(available.splice(idx, 1)[0].id);
              }

              selectedEnemies = chosen;
              syncEnemyControls();
            }

            function randomizeAllies() {
              alliesUndoStack.push([...selectedAllies]);
              alliesRedoStack = [];

              alliesCount = Math.floor(Math.random() * 36) + 15; // 15–50
              alliesSlider.value = alliesCount;

              const available = [...allies];
              const chosen = [];
              while (chosen.length < alliesCount && available.length > 0) {
                const idx = Math.floor(Math.random() * available.length);
                chosen.push(available.splice(idx, 1)[0].id);
              }

              selectedAllies = chosen;
              syncAllyControls();
            }

            document.getElementById('random-enemies').addEventListener('click', () => {
              randomizeEnemies();
              randomizeAllies();
            });

            document.getElementById('undo-enemies').addEventListener('click', () => {
              if (enemiesUndoStack.length > 0) {
                enemiesRedoStack.push(enemiesCount);
                enemiesCount = enemiesUndoStack.pop();
                enemiesSlider.value = enemiesCount;
                syncEnemyControls();
              }
              if (alliesUndoStack.length > 0) {
                alliesRedoStack.push(alliesCount);
                alliesCount = alliesUndoStack.pop();
                alliesSlider.value = alliesCount;
                syncAllyControls();
              }
            });

            document.getElementById('redo-enemies').addEventListener('click', () => {
              if (enemiesRedoStack.length > 0) {
                enemiesUndoStack.push(enemiesCount);
                enemiesCount = enemiesRedoStack.pop();
                enemiesSlider.value = enemiesCount;
                syncEnemyControls();
              }
              if (alliesRedoStack.length > 0) {
                alliesUndoStack.push(alliesCount);
                alliesCount = alliesRedoStack.pop();
                alliesSlider.value = alliesCount;
                syncAllyControls();
              }
            });

            // ===================== VILLAIN DECK STATE =====================
            let mightsCount = 8;     // 3–10 (recommended 8)
            let bystandersCount = 10; // 7–15 (recommended 10)
            let bystandersByType = []; // [{id,name,count}]

            let selectedScenarios = [];    // ids (0–5 allowed)
            let scenariosUndoStack = [];
            let scenariosRedoStack = [];

            let henchmenCounts = new Map(); // key: henchmen id, value: qty (0–10)
            let henchmenUndoStack = [];
            let henchmenRedoStack = [];

            let selectedVillains = new Set(); // one each allowed (checkbox per villain)
            let openVillainGroups = new Set();
            let villainsUndoStack = [];
            let villainsRedoStack = [];

            const mightsSlider = document.getElementById('mights-slider');
            const mightsValue  = document.getElementById('mights-value');
            const mightsInput  = document.getElementById('mights-input');

            const bysSlider = document.getElementById('bystanders-slider');
            const bysValue  = document.getElementById('bystanders-value');
            const bysInput  = document.getElementById('bystanders-input');
            const bysBreak  = document.getElementById('bystanders-breakdown');

            const scenariosGrid = document.getElementById('scenarios-grid');

            const hGrid1 = document.getElementById('henchmen-grid-1');
            const hGrid2 = document.getElementById('henchmen-grid-2');
            const hGrid3 = document.getElementById('henchmen-grid-3');
            const henchmenTotalEl = document.getElementById('henchmen-total');

            const villainsGroups = document.getElementById('villains-groups');
            const villainsTotalEl = document.getElementById('villains-total');

            const deckTotalEl = document.getElementById('villain-deck-total');

            function clamp(n, lo, hi){ return Math.max(lo, Math.min(hi, n)); }
            function setAccent(el, valid){ el.style.accentColor = valid ? 'green':'red'; }
            function moveLabelToSlider(slider,label){
              const pct = (Number(slider.value) / Number(slider.max)) * 100;
              label.textContent = slider.value;
              label.style.left = `${pct}%`;
              label.style.transform = 'translateX(-50%)';
            }

            // ----- Mights -----
            function syncMights(){
              mightsCount = Number(mightsSlider.value);
              mightsInput.value = mightsCount;
              moveLabelToSlider(mightsSlider, mightsValue);
              // valid range 3–10
              setAccent(mightsSlider, mightsCount >= 3 && mightsCount <= 10);
              updateStartButton();
            }
            mightsSlider.addEventListener('input', syncMights);
            mightsInput.addEventListener('input', e => {
              const v = clamp(Number(e.target.value)||0, 0, 10);
              mightsSlider.value = v; syncMights();
            });

            // ----- Bystanders -----
            function distributeBystanders(total){
              // Even distribution across types currently available
              const types = bystanders.filter(b => String(b.doNotShow).toLowerCase() !== 'true');
              if (types.length === 0){ bystandersByType = []; return; }
              const base = Math.floor(total / types.length);
              let rem = total % types.length;
              bystandersByType = types.map(t => ({ id:String(t.id), name:t.name, count: base }));
              for (let i=0;i<bystandersByType.length && rem>0;i++,rem--) bystandersByType[i].count += 1;
            }
            function renderBystandersBreakdown(){
              if (!bystandersByType.length){ bysBreak.innerHTML = '<i>No bystanders</i>'; return; }
              bysBreak.innerHTML = '<ul style="margin:0;padding-left:16px;">'+
                bystandersByType.filter(x=>x.count>0).map(x => `<li>${x.count}× ${x.name}</li>`).join('')+
                '</ul>';
            }
            function syncBystanders(){
              bystandersCount = Number(bysSlider.value);
              bysInput.value = bystandersCount;
              moveLabelToSlider(bysSlider, bysValue);
              // valid 7–15
              setAccent(bysSlider, bystandersCount >= 7 && bystandersCount <= 15);
              distributeBystanders(bystandersCount);
              renderBystandersBreakdown();
              updateStartButton();
            }
            bysSlider.addEventListener('input', syncBystanders);
            bysInput.addEventListener('input', e => {
              const v = clamp(Number(e.target.value)||0, 0, 15);
              bysSlider.value = v; syncBystanders();
            });

            // init values
            syncMights();
            syncBystanders();

            // ===================== SCENARIOS =====================
            let filteredScenarios = scenarios
              .filter(s => String(s.doNotShow).toLowerCase() !== 'true')
              .sort((a,b) => a.name.localeCompare(b.name));

            // render cards (white bubble on gray sub)
            function renderScenarios(){
              scenariosGrid.innerHTML = '';
              filteredScenarios.forEach(s=>{
                const card = document.createElement('div');
                card.className = 'tactic-card'; // re-use same white bubble styling
                card.dataset.id = s.id;
                const h = document.createElement('h3'); h.textContent = s.name;
                const p = document.createElement('p');
                const raw = Array.isArray(s.abilitiesText)
                  ? s.abilitiesText.map(a => a.text).join('<br><br>')
                  : '';
                p.innerHTML = renderAbilityText(raw);
                card.appendChild(h); card.appendChild(p);
                if (selectedScenarios.includes(String(s.id))) card.classList.add('selected');
                card.addEventListener('click', ()=>{
                  const id = String(s.id);
                  const i = selectedScenarios.indexOf(id);
                  if (i>-1) selectedScenarios.splice(i,1);
                  else if (selectedScenarios.length < 5) selectedScenarios.push(id);
                  renderScenarios(); updateStartButton();
                });
                scenariosGrid.appendChild(card);
              });
            }
            renderScenarios();

            function randomScenarios(){
              const avail = filteredScenarios.filter(s => !selectedScenarios.includes(String(s.id)));
              const pick = Math.floor(Math.random()*Math.min(5-selectedScenarios.length, Math.max(1, avail.length))) || 1;
              scenariosUndoStack.push([...selectedScenarios]); scenariosRedoStack = [];
              const bag = [...avail]; const add=[];
              while(add.length < pick && bag.length){
                const i = Math.floor(Math.random()*bag.length);
                add.push(String(bag.splice(i,1)[0].id));
              }
              selectedScenarios = [...selectedScenarios, ...add]; renderScenarios(); updateStartButton();
            }
            function undoScenarios(){ if(!scenariosUndoStack.length) return; scenariosRedoStack.push([...selectedScenarios]); selectedScenarios = scenariosUndoStack.pop(); renderScenarios(); updateStartButton(); }
            function redoScenarios(){ if(!scenariosRedoStack.length) return; scenariosUndoStack.push([...selectedScenarios]); selectedScenarios = scenariosRedoStack.pop(); renderScenarios(); updateStartButton(); }

            document.getElementById('random-scenarios').addEventListener('click', randomScenarios);
            document.getElementById('undo-scenarios').addEventListener('click', undoScenarios);
            document.getElementById('redo-scenarios').addEventListener('click', redoScenarios);

            // ===================== HENCHMEN =====================
            const henchFiltered = henchmen
              .filter(h => String(h.doNotShow).toLowerCase() !== 'true')
              .map(h => ({
                ...h,
                power: Number(h.hp) || 1   // directly use the card's own power value
              }))
              .sort((a,b) => a.name.localeCompare(b.name));

            function henchCard(h){
              const wrap = document.createElement('div');
              wrap.style.cssText = 'display:flex; flex-direction:column; align-items:center; gap:4px; padding:6px; border-radius:8px; width:190px;';
              const img = document.createElement('img');
              img.src = h.image; img.alt = h.name; img.style.cssText='width:80px;height:80px;object-fit:cover;border:2px solid black;border-radius:6px;';
              const name = document.createElement('div');
              name.style.cssText = 'font-weight:bold; font-size:0.7rem; text-align:center;';
              name.textContent = h.name;
              const qty = document.createElement('input');
              qty.type='number'; qty.min='0'; qty.max='10'; qty.value = henchmenCounts.get(String(h.id)) ?? 0;
              qty.style.cssText = 'width:30px; text-align:center; font-size:0.6rem;';
              qty.addEventListener('input', ()=>{
                const v = clamp(Number(qty.value)||0, 0, 10);
                qty.value = v;
                henchmenCounts.set(String(h.id), v);
                renderHenchmenTotals();
                updateStartButton();
              });
              wrap.appendChild(img); wrap.appendChild(name);
              const box = document.createElement('div');
              box.style.cssText='display:flex;align-items:center;gap:6px;';
              const label = document.createElement('span');
              label.style.cssText = 'font-size:0.65rem;';
              label.textContent = 'Qty:';
              box.appendChild(label); box.appendChild(qty);
              wrap.appendChild(box);
              return wrap;
            }

            function renderHenchmen(){
              [hGrid1,hGrid2,hGrid3].forEach(g=>g.innerHTML='');
              henchFiltered.filter(h=>h.power===1).forEach(h=> hGrid1.appendChild(henchCard(h)));
              henchFiltered.filter(h=>h.power===2).forEach(h=> hGrid2.appendChild(henchCard(h)));
              henchFiltered.filter(h=>h.power===3).forEach(h=> hGrid3.appendChild(henchCard(h)));
              renderHenchmenTotals();
            }
            function renderHenchmenTotals(){
              let total = 0; henchmenCounts.forEach(v => total += (Number(v)||0));
              henchmenTotalEl.textContent = `Total: ${total}`;
            }
            renderHenchmen();

            function randomHenchmen(){
              henchmenUndoStack.push([...henchmenCounts.entries()]); henchmenRedoStack = [];
              // Assign random 0–10 to some entries until 20–40 total
              henchmenCounts.clear();
              let total = 0;
              const pool = [...henchFiltered];
              while (pool.length && total < 20){
                const i = Math.floor(Math.random()*pool.length);
                const h = pool.splice(i,1)[0];
                const qty = Math.floor(Math.random()*11); // 0–10
                henchmenCounts.set(String(h.id), qty);
                total += qty;
              }
              // If still low (<20), top up randomly; if high (>40), trim
              if (total < 20){
                for (const h of henchFiltered){
                  if (total>=20) break;
                  const id = String(h.id);
                  const cur = henchmenCounts.get(id) ?? 0;
                  const add = clamp(20-total, 0, 10-cur);
                  henchmenCounts.set(id, cur+add);
                  total += add;
                }
              } else if (total > 40){
                for (const h of henchFiltered){
                  if (total<=40) break;
                  const id = String(h.id);
                  const cur = henchmenCounts.get(id) ?? 0;
                  const rem = clamp(total-40, 0, cur);
                  henchmenCounts.set(id, cur-rem);
                  total -= rem;
                }
              }
              renderHenchmen(); updateStartButton();
            }
            function undoHenchmen(){ if(!henchmenUndoStack.length) return; henchmenRedoStack.push([...henchmenCounts.entries()]); henchmenCounts = new Map(henchmenUndoStack.pop()); renderHenchmen(); updateStartButton();}
            function redoHenchmen(){ if(!henchmenRedoStack.length) return; henchmenUndoStack.push([...henchmenCounts.entries()]); henchmenCounts = new Map(henchmenRedoStack.pop()); renderHenchmen(); updateStartButton();}
            document.getElementById('random-henchmen').addEventListener('click', randomHenchmen);
            document.getElementById('undo-henchmen').addEventListener('click', undoHenchmen);
            document.getElementById('redo-henchmen').addEventListener('click', redoHenchmen);
            document.getElementById('henchmen-deselect-all').addEventListener('click', ()=>{ henchmenCounts.clear(); renderHenchmen(); updateStartButton(); });

            // ===================== VILLAINS =====================
            const heroMapIdToHero = new Map(heroes.map(h => [String(h.id), h]));
            const villainByHero = new Map();

            // group villains by hero (use 999 for "Misc" or when missing)
            villains
              .filter(v => String(v.doNotShow).toLowerCase() !== 'true')
              .forEach(v => {
                const heroId = String(v.heroId ?? (v.hero === 'Misc' ? 999 : v.hero));
                if (!villainByHero.has(heroId)) villainByHero.set(heroId, []);
                villainByHero.get(heroId).push(v);
              });

            // Render grouped collapsibles; skip empty categories
            function renderVillainGroups(){
              villainsGroups.innerHTML = '';
              // order by hero id, put 999 (Misc) last
              const heroIds = [...villainByHero.keys()].sort((a,b)=>{
                if (a==='999' && b!=='999') return 1;
                if (b==='999' && a!=='999') return -1;
                return Number(a)-Number(b);
              });
              heroIds.forEach(hid=>{
                const list = villainByHero.get(hid);
                if (!list || !list.length) return;

                const heroName = (hid==='999' ? 'Misc' : (heroMapIdToHero.get(hid)?.name ?? `${hid}`));

                // --- unified clickable header with checkbox ---
                const header = document.createElement('div');
                header.className = 'collapsible villain-collapsible';
                header.style.cssText = `
                  display:flex; align-items:center; justify-content:space-between;
                  margin-top:10px; border:2px solid black; border-radius:6px;
                  background:#f5f5f5; padding:6px 10px; cursor:pointer; font-weight:bold;
                `;

                const label = document.createElement('div');
                label.textContent = `${heroName}'s Villains`;

                // Look up this hero's color from faceCards.js
                const matchingHero = heroes.find(h => h.name === heroName);
                const heroColor = matchingHero ? matchingHero.color : '#5d5d5d';

                // Apply that color to the header background and border
                header.style.backgroundColor = heroColor;
                header.style.borderColor = 'black';
                header.style.color = 'white';

                // --- Compute pale variant ---
                function lightenColor(color) {
                  const map = {
                    red: '#ffcccc',
                    blue: '#cce0ff',
                    green: '#ccffcc',
                    yellow: '#fff7cc',
                    orange: '#ffe5cc',
                    aqua: '#ccffff',
                    ivory: '#fffff0',
                    DarkRed: '#d28a8a',
                    // default fallback
                    default: '#f0f0f0'
                  };
                  return map[color] || map.default;
                }
                const paleColor = lightenColor(heroColor);


                const right = document.createElement('label');
                right.style.cssText = 'display:flex; align-items:center; gap:6px; cursor:default;';
                const cb = document.createElement('input');
                cb.type = 'checkbox';
                cb.checked = list.every(v => selectedVillains.has(String(v.id)));
                right.appendChild(document.createTextNode('Select All'));
                right.appendChild(cb);

                header.appendChild(label);
                header.appendChild(right);
                villainsGroups.appendChild(header);

                // content directly under header
                const cont = document.createElement('div');
                cont.className = 'content';
                cont.style.cssText = `
                  border:2px solid black;
                  border-top:none;
                  border-radius:0 0 6px 6px;
                  padding:10px;
                  margin-bottom:10px;
                  width:100%; /* matches header’s border width */
                  background-color:${paleColor};
                `;
                const grid = document.createElement('div');
                grid.className = 'category-group';
                grid.style.background = 'none';
                grid.style.border = 'none';
                grid.style.borderRadius = '0';

                // restore open/closed state for this hero
                if (openVillainGroups.has(hid)) {
                  cont.classList.add('show');
                  header.classList.add('active');
                }

                // expand/collapse by clicking anywhere except the checkbox
                header.addEventListener('click', (e) => {
                  if (e.target === cb) return; // ignore checkbox click
                  const isOpen = cont.classList.toggle('show');
                  header.classList.toggle('active', isOpen);

                  if (isOpen) {
                    // when open: seamless merge into the dropdown
                    header.style.borderBottom = 'none';
                    header.style.borderBottomLeftRadius = '0';
                    header.style.borderBottomRightRadius = '0';
                    cont.style.borderTop = 'none';
                  } else {
                    // restore normal styling when closed
                    header.style.borderBottom = '2px solid black';
                    header.style.borderBottomLeftRadius = '6px';
                    header.style.borderBottomRightRadius = '6px';
                    cont.style.borderTop = '2px solid black';
                  }

                  if (isOpen) openVillainGroups.add(hid);
                  else openVillainGroups.delete(hid);
                });

                list.sort((a,b)=> a.name.localeCompare(b.name)).forEach(v => {
                  const card = document.createElement('div');
                  card.style.cssText = `
                    width:120px; padding:4px; display:flex;
                    flex-direction:column; align-items:center; gap:4px; cursor:pointer; border:none;
                  `;
                  card.dataset.id = v.id;

                  const img = document.createElement('img');
                  img.src = v.image;
                  img.alt = v.name;
                  img.style.cssText = `
                    width:100px; height:100px; object-fit:cover; border:2px solid black; border-radius:8px;
                  `;

                  const name = document.createElement('div');
                  name.style.cssText = 'font-weight:bold; text-align:center; font-size:14px;';
                  name.textContent = v.name;

                  const stats = document.createElement('div');
                  stats.style.cssText = 'font-size:12px; text-align:center; color:#333;';
                  stats.textContent = `${v.hp} HP • ${v.damage} DMG`;

                  // highlight if selected
                  if (selectedVillains.has(String(v.id))) {
                    card.style.boxShadow = '0 0 10px 4px yellow';
                  }

                  // IMPORTANT: do NOT rebuild; just mutate state + visuals
                  card.addEventListener('click', (e) => {
                    e.stopPropagation(); // never collapse when clicking a card
                    const id = String(v.id);
                    if (selectedVillains.has(id)) selectedVillains.delete(id);
                    else selectedVillains.add(id);

                    // update visuals in place
                    card.style.boxShadow = selectedVillains.has(id) ? '0 0 10px 4px yellow' : '';
                    // sync "Select All" checkbox for this hero
                    cb.checked = list.every(x => selectedVillains.has(String(x.id)));

                    // update totals and validity
                    renderVillainTotals();
                    updateStartButton(); // this updates Deck Total readout
                  });

                  card.appendChild(img);
                  card.appendChild(name);
                  card.appendChild(stats);
                  grid.appendChild(card);
                });

                cont.appendChild(grid);
                villainsGroups.appendChild(cont);

                // Select/Deselect all without rebuilding
                cb.addEventListener('change', (e) => {
                  if (cb.checked) list.forEach(v => selectedVillains.add(String(v.id)));
                  else list.forEach(v => selectedVillains.delete(String(v.id)));

                  // update every card in this grid to match the new selection
                  Array.from(grid.children).forEach(cardEl => {
                    const id = String(cardEl.dataset.id);
                    cardEl.style.boxShadow = selectedVillains.has(id) ? '0 0 10px 4px yellow' : '';
                  });

                  renderVillainTotals();
                  updateStartButton();
                });
              });
            }

            function renderVillainTotals(){
              villainsTotalEl.textContent = `Total: ${selectedVillains.size}`;
            }

            function randomVillains(){
              villainsUndoStack.push(new Set(selectedVillains)); villainsRedoStack = [];
              selectedVillains.clear();
              // pick between 30–70 (or as many as exist)
              const pool = villains.filter(v => String(v.doNotShow).toLowerCase() !== 'true');
              const need = clamp(Math.floor(Math.random()*41)+30, 0, pool.length);
              const bag = [...pool];
              while (selectedVillains.size < need && bag.length){
                const i = Math.floor(Math.random()*bag.length);
                selectedVillains.add(String(bag.splice(i,1)[0].id));
              }
              renderVillainTotals(); renderVillainGroups(); updateStartButton();
            }
            function undoVillains(){ if(!villainsUndoStack.length) return; villainsRedoStack.push(new Set(selectedVillains)); selectedVillains = villainsUndoStack.pop(); renderVillainTotals(); renderVillainGroups(); updateStartButton();}
            function redoVillains(){ if(!villainsRedoStack.length) return; villainsUndoStack.push(new Set(selectedVillains)); selectedVillains = villainsRedoStack.pop(); renderVillainTotals(); renderVillainGroups(); updateStartButton();}

            document.getElementById('random-villains').addEventListener('click', randomVillains);
            document.getElementById('undo-villains').addEventListener('click', undoVillains);
            document.getElementById('redo-villains').addEventListener('click', redoVillains);
            document.getElementById('villains-deselect-all').addEventListener('click', ()=>{ selectedVillains.clear(); renderVillainTotals(); renderVillainGroups(); updateStartButton(); });

            // initial render
            renderVillainGroups(); renderVillainTotals();

            // Include in export/import
            function exportLoadout() {
              const data = {
                heroes: selectedOrder,
                overlords: selectedOverlords,
                tactics: selectedTactics,
                enemies: { count: enemiesCount, ids: selectedEnemies },
                allies: { count: alliesCount, ids: selectedAllies },
                villainDeck: {
                  mights: mightsCount,
                  bystanders: {
                    count: bystandersCount,
                    byType: bystandersByType
                  },
                  scenarios: selectedScenarios, // ids
                  henchmen: Array.from(henchmenCounts.entries()).map(([id,count]) => ({id, count})),
                  villains: Array.from(selectedVillains) // ids
                }
              };
              const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
              const url = URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              a.download = 'loadout.json';
              a.click();
              URL.revokeObjectURL(url);
            }


            // --- Import loadout from user file (Unified) ---
            function importLoadout(event) {
              const file = event.target.files[0];
              if (!file) return;

              const reader = new FileReader();
              reader.onload = e => {
                try {
                  const data = JSON.parse(e.target.result);

                  // --- HEROES ---
                  if (Array.isArray(data.heroes)) {
                    selectedOrder = data.heroes.slice(0, 6);
                    updateBadges();
                  }

                  // --- OVERLORDS ---
                  if (Array.isArray(data.overlords)) {
                    selectedOverlords = data.overlords.slice(0, 3);
                    updateOverlordBadges();
                  }

                  // --- TACTICS ---
                  if (Array.isArray(data.tactics)) {
                    selectedTactics = data.tactics.slice(0, 2);
                    updateTacticStyles();
                  }

                  // --- ENEMIES ---
                  if (typeof data.enemies === 'object' && data.enemies !== null) {
                    selectedEnemies = Array.isArray(data.enemies.ids) ? data.enemies.ids : [];
                    enemiesCount = data.enemies.count || selectedEnemies.length;
                    enemiesSlider.value = enemiesCount;
                    syncEnemyControls();
                  }

                  // --- ALLIES ---
                  if (typeof data.allies === 'object' && data.allies !== null) {
                    selectedAllies = Array.isArray(data.allies.ids) ? data.allies.ids : [];
                    alliesCount = data.allies.count || selectedAllies.length;
                    alliesSlider.value = alliesCount;
                    syncAllyControls();
                  }

                  // --- VILLAIN DECK ---
                  if (data.villainDeck){
                    // Mights
                    if (typeof data.villainDeck.mights === 'number'){
                      mightsCount = clamp(data.villainDeck.mights, 0, 10);
                      mightsSlider.value = mightsCount; syncMights();
                    }
                    // Bystanders
                    if (data.villainDeck.bystanders){
                      const bd = data.villainDeck.bystanders;
                      bystandersCount = clamp(Number(bd.count)||0, 0, 15);
                      bysSlider.value = bystandersCount; syncBystanders();
                      if (Array.isArray(bd.byType)) { bystandersByType = bd.byType; renderBystandersBreakdown(); }
                    }
                    // Scenarios
                    if (Array.isArray(data.villainDeck.scenarios)){
                      selectedScenarios = data.villainDeck.scenarios.slice(0,5).map(String);
                      renderScenarios();
                    }
                    // Henchmen
                    if (Array.isArray(data.villainDeck.henchmen)){
                      henchmenCounts.clear();
                      data.villainDeck.henchmen.forEach(x=>{
                        if (x && x.id!=null) henchmenCounts.set(String(x.id), clamp(Number(x.count)||0,0,10));
                      });
                      renderHenchmen();
                    }
                    // Villains
                    if (Array.isArray(data.villainDeck.villains)){
                      selectedVillains = new Set(data.villainDeck.villains.map(String));
                      renderVillainTotals(); renderVillainGroups();
                    }
                  }

                  updateStartButton();
                } catch (err) {
                  console.error('Failed to import loadout:', err);
                  alert('Invalid file format. Please use a valid .json loadout file.');
                }
              };

              reader.readAsText(file);
            }

            const limits = {
              heroes: { min: 1, max: 6 },
              overlords: { min: 1, max: 3 },
              tactics: { min: 1, max: 2 }
            };

            function topRandom() {
              // --- First, randomize tactics so restrictions can be read ---
              if (selectedTactics.length < limits.tactics.min) randomizeTactics();

              // --- Analyze selected tactics for special restrictions ---
              let enemiesOnly = false;
              let minEnemies = 15;
              let minAllies = 15;
              let requireTwoTactics = false;
              let requireTwoOverlords = false;

              for (const tacticId of selectedTactics) {
                const t = tactics.find(tt => String(tt.id) === String(tacticId));
                if (!t) continue;

                if (Array.isArray(t.limitEaA) && t.limitEaA[0] === "allEnemies") {
                  enemiesOnly = true;
                  const match = t.limitEaA[1].match(/\d+/);
                  minEnemies = match ? Number(match[0]) : 30;
                  minAllies = 0;
                }

                if (t.multiTacticReq === "yes") requireTwoTactics = true;
                if (t.multiOverlordReq === "yes") requireTwoOverlords = true;
              }

              // --- HEROES ---
              if (selectedOrder.length < limits.heroes.min) randomizeSelection();

              // --- OVERLORDS ---
              if (requireTwoOverlords && selectedOverlords.length < 2) {
                while (selectedOverlords.length < 2) randomizeOverlords();
              } else if (selectedOverlords.length < limits.overlords.min) {
                randomizeOverlords();
              }

              // --- TACTICS (ensure at least required number) ---
              if (requireTwoTactics && selectedTactics.length < 2) {
                while (selectedTactics.length < 2) randomizeTactics();
              }

              // --- ENEMIES & ALLIES ---
              if (enemiesOnly) {
                enemiesCount = Math.floor(Math.random() * (50 - minEnemies + 1)) + minEnemies;
                alliesCount = 0;
              } else {
                enemiesCount = Math.floor(Math.random() * 36) + 15;
                alliesCount = Math.floor(Math.random() * 36) + 15;
              }

              // Apply to sliders and sync visuals
              enemiesSlider.value = enemiesCount;
              alliesSlider.value = alliesCount;
              syncEnemyControls();
              syncAllyControls();

              // --- VILLAIN DECK RANDOMIZATION ---
              mightsCount = Math.floor(Math.random()*(10-3+1))+3;
              bystandersCount = Math.floor(Math.random()*(15-7+1))+7;
              mightsSlider.value = mightsCount; moveLabelToSlider(mightsSlider, mightsValue);
              bysSlider.value = bystandersCount; moveLabelToSlider(bysSlider, bysValue);
              distributeBystanders(bystandersCount); renderBystandersBreakdown();

              // Scenarios: 0–2 randomly (bias to recommended 2)
              selectedScenarios = [];
              if (Math.random()<0.15) selectedScenarios = []; else {
                const want = Math.random()<0.25 ? 1 : 2;
                const bag = [...filteredScenarios];
                while (selectedScenarios.length < want && bag.length){
                  const i = Math.floor(Math.random()*bag.length);
                  selectedScenarios.push(String(bag.splice(i,1)[0].id));
                }
              }
              renderScenarios();

              // Henchmen: try to hit 20–40 total, each 0–10
              henchmenCounts.clear();
              let targetH = Math.floor(Math.random()*(40-20+1))+20;
              let remain = targetH;
              const hbag = [...henchFiltered];
              while (hbag.length && remain>0){
                const i = Math.floor(Math.random()*hbag.length);
                const h = hbag.splice(i,1)[0];
                const take = clamp(Math.floor(Math.random()*Math.min(11, remain+1)), 0, 10);
                henchmenCounts.set(String(h.id), take);
                remain -= take;
              }
              if (remain>0){
                for (const h of henchFiltered){
                  if (remain<=0) break;
                  const id = String(h.id);
                  const cur = henchmenCounts.get(id) ?? 0;
                  const add = clamp(remain, 0, 10-cur);
                  henchmenCounts.set(id, cur+add);
                  remain -= add;
                }
              }
              renderHenchmen();

              // Villains: 30–70
              selectedVillains.clear();
              {
                const pool = villains.filter(v => String(v.doNotShow).toLowerCase() !== 'true');
                const want = clamp(Math.floor(Math.random()*41)+30, 0, pool.length);
                const bag = [...pool];
                while (selectedVillains.size < want && bag.length){
                  const i = Math.floor(Math.random()*bag.length);
                  selectedVillains.add(String(bag.splice(i,1)[0].id));
                }
              }
              renderVillainTotals(); renderVillainGroups();

              // Refresh visuals
              updateBadges();
              updateOverlordBadges();
              updateTacticStyles();
              updateStartButton();
            }

            document.getElementById('top-random').addEventListener('click', topRandom);
        </script>
    </body>
</html>