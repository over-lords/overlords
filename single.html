<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover">
  <link href='https://fonts.googleapis.com/css?family=Racing Sans One' rel='stylesheet'>
  <link rel="icon" href="https://raw.githubusercontent.com/over-lords/overlords/4c614c1ffe5a9d7194202bd24fae5e7c99d86333/Public/Images/Site%20Assets/favicon.png" type="image/png">
  <link rel="stylesheet" href="style.css">
  <title>Overlords</title>
  <style>
  .hero-box {
  background-color: rgba(255, 255, 255, 0.9);
  border: none;                  /* remove inner border so it blends into dropdown */
  border-radius: 0 0 6px 6px;    /* keep rounded bottom to match dropdown */
  margin: 0;                     /* remove outside margins */
  padding: 15px;
  width: 100%;                   /* fill full dropdown width */
  box-sizing: border-box;        /* include padding in total width */
}
.hero-controls {
  display: flex;
  justify-content: center;
  gap: 15px;
  margin-bottom: 15px;
}
.hero-controls button {
  background-color: yellow;
  border: 2px solid black;
  border-radius: 4px;
  font-weight: bold;
  padding: 5px 12px;
  cursor: pointer;
}

.top-row {
  width: 95%;
  max-width: 1200px;
  margin: 10px auto 20px auto;
  display: flex;
  align-items: center;
  justify-content: space-between;
  position: relative;
}

.import-btn {
  background-color: yellow;
  border: 2px solid black;
  border-radius: 4px;
  font-weight: bold;
  padding: 6px 12px;
  cursor: pointer;
  position: absolute;
  left: 0;
}

.top-random-btn {
  background-color: yellow;
  border: 2px solid black;
  border-radius: 4px;
  font-weight: bold;
  padding: 6px 12px;
  cursor: pointer;
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
}

/* --- BOTTOM ROW --- */
.bottom-row {
  width: 95%;
  max-width: 1200px;
  margin: 25px auto 40px auto;
  display: flex;
  align-items: center;
  justify-content: space-between;
  position: relative;
}

.start-button {
  background-color: gray;
  border: 3px solid black;
  border-radius: 6px;
  color: black;
  font-weight: bold;
  font-size: 1.2rem;
  width: 250px;
  text-align: center;
  padding: 10px;
  cursor: not-allowed;
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
}

.start-button.active {
  background-color: yellow;
  cursor: pointer;
}

.export-btn {
  background-color: yellow;
  border: 2px solid black;
  border-radius: 4px;
  font-weight: bold;
  padding: 8px 16px;
  cursor: pointer;
  position: absolute;
  right: 0;
}
  /* Category container – wraps heroes into responsive rows */
  .category-group {
    border: 2px solid black;
    border-radius: 6px;
    margin: 15px 0;
    padding: 10px;
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 15px;
  }
  .guardian-bg { background-color: rgba(173, 216, 230, 0.5); }  /* Light blue */
  .striker-bg  { background-color: rgba(255, 182, 193, 0.5); }  /* Light red */
  .tactician-bg{ background-color: rgba(255, 255, 153, 0.5); }  /* Light yellow */

  .hero-category-title {
    flex-basis: 100%;
    text-align: center;
    font-weight: bold;
    font-size: 1.3rem;
    margin-bottom: 5px;
    text-shadow: 0 0 3px white;
  }

  .hero-card {
    text-align: center;
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
  }

  .hero-card img {
    width: 100px;
    height: 100px;
    object-fit: cover;
    border: 2px solid black;
    border-radius: 4px;
  }

  .hero-card.selected img {
    box-shadow: 0 0 10px 5px yellow;
    transform: scale(1.05);
  }

  .hero-card p {
    margin-top: 5px;
    font-weight: bold;
    font-size: 0.9rem;
  }

  .container {
    display: flex;
    flex-direction: column;
    align-items: center;
    }
  .collapsible {
  background-color: #5d5d5d;
  color: white;
  cursor: pointer;
  padding: 10px;
  width: 95%;
  max-width: 1200px;
  border: 2px solid black;
  border-radius: 6px;
  text-align: center;
  margin: 20px auto 0 auto;
  font-weight: bold;
  transition: border-radius 0.2s ease, border-bottom 0.2s ease;
  box-sizing: border-box;
}

.collapsible.active {
  background-color: #777;
  border-bottom: none;
  border-radius: 6px 6px 0 0;
}

.content {
  display: none;
  overflow: hidden;
  width: 95%;
  max-width: 1200px;
  margin: 0 auto;
  border: 2px solid black;
  border-top: none;             /* merge with open button border */
  border-radius: 0 0 6px 6px;
  box-sizing: border-box;       /* ensures exact same width */
}

.content.show {
  display: block;
}

  .start-button {
    background-color: gray;
    border: 3px solid black;
    border-radius: 6px;
    color: black;
    font-weight: bold;
    font-size: 1.2rem;
    width: 250px;
    text-align: center;
    margin: 20px auto;
    padding: 10px;
    cursor: not-allowed;
  }

  .start-button.active {
    background-color: yellow;
    cursor: pointer;
  }
  .boxed {
    display: inline-block;
    border: 3px solid black;
    background-color: rgba(255, 255, 255, 0.9);
    padding: 6px 10px;
    border-radius: 4px;
  }
  .hero-card { position: relative; }
.selection-badge {
  position: absolute;
  top: -6px;
  right: -6px;
  width: 26px;
  height: 26px;
  border-radius: 50%;
  background: yellow;
  border: 2px solid black;
  color: black;
  font-weight: 800;
  display: none;
  align-items: center;
  justify-content: center;
  font-size: 14px;
}
.hero-image-wrapper {
  position: relative;
  display: inline-block;  /* keeps wrapper tight to image */
}

.overlord-card {
  text-align: center;
  cursor: pointer;
  transition: transform 0.2s, box-shadow 0.2s;
  position: relative;
}

.overlord-card img {
  width: 100px;
  height: 100px;
  object-fit: cover;
  border: 2px solid black;
  border-radius: 6px;
}
.overlord-card.selected img {
  box-shadow: 0 0 12px 6px yellow;
  transform: scale(1.05);
}
.overlord-card p {
  margin: 5px 0;
  font-weight: bold;
}
.difficulty-1 {
  background-color: rgba(0, 255, 0, 0.2);
}
.difficulty-2 {
  background-color: rgba(255, 255, 0, 0.2);
}
.difficulty-3 {
  background-color: rgba(255, 0, 0, 0.2);
}
.difficulty-title {
  flex-basis: 100%;
  font-weight: bold;
  margin-top: 10px;
  text-align: center;
}
#tactics-grid {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 10px;
  margin-top: 10px;
}

.tactic-card {
  background-color: white;
  border: 2px solid black;
  border-radius: 12px;
  padding: 10px 15px;
  width: 80%;
  cursor: pointer;
  transition: transform 0.2s, box-shadow 0.2s;
  text-align: left;
  box-sizing: border-box;
}

.tactic-card:hover {
  transform: scale(1.02);
  box-shadow: 0 0 6px rgba(0,0,0,0.3);
}

.tactic-card.selected {
  box-shadow: 0 0 10px 4px yellow;
}

.tactic-card h3 {
  margin: 0;
  font-size: 1rem;
  font-weight: bold;
}

.tactic-card p {
  margin: 5px 0 0 0;
  font-size: 0.9rem;
}
</style>
</head>
    <body style="background-color:white;" onload="window.scrollTo(0, 1)">
        <div class="bg-image" alt="" style="opacity: 35%;"></div>
        <div class="container">
            <div class="title-box" id="title-box"></div>
            <h1 class="glow-red" style="pointer-events: none;">Overlords</h1>

            <div id="close-box" onclick="location.href='play.html'">X</div>

            <div class="container" style="margin-top: 110px; width: 100%;">
                <p class="boxed" style="font-weight: bold; font-family: 'Poppins', sans-serif;">Design your Singleplayer game!</p>
                <div class="top-row">
                  <button id="import-loadout" class="import-btn">Import Loadout</button>
                  <button id="top-random" class="top-random-btn">Random</button>
                </div>
                <button class="collapsible">Select Your Heroes (1-6)</button>
                <div class="content">
                <div class="hero-box">
                  <div class="hero-controls">
                    <button id="undo-random">Undo</button>
                    <button id="random-heroes">Random</button>
                    <button id="redo-random">Redo</button>
                  </div>
                    <div id="hero-grid" class="hero-grid"></div>
                </div>
                </div>

                <button class="collapsible">Select Your Overlords (1-3)</button>
                <div class="content">
                  <div class="hero-box">
                    <div class="hero-controls">
                      <button id="undo-overlords">Undo</button>
                      <button id="random-overlords">Random</button>
                      <button id="redo-overlords">Redo</button>
                    </div>
                    <div id="overlord-grid" class="hero-grid"></div>
                  </div>
                </div>

                <button class="collapsible">Select Your Tactics (1-2)</button>
                <div class="content">
                  <div class="hero-box" style="background-color: #ccc;">
                    <div class="hero-controls">
                      <button id="undo-tactics">Undo</button>
                      <button id="random-tactics">Random</button>
                      <button id="redo-tactics">Redo</button>
                    </div>
                    <div id="tactics-grid" class="hero-grid"></div>
                  </div>
                </div>

                <br>
                <div class="bottom-row">
                  <button id="start-button" class="start-button">Start Game!</button>
                  <button id="export-loadout" class="export-btn">Export Loadout</button>
                </div>
                <br><br><br>
            </div>
        </div>

        <script type="module">
            import { heroes } from './data/faceCards.js';
            import { overlords } from './data/overlords.js';
            import { tactics } from './data/tactics.js';

            const collapsible = document.querySelector('.collapsible');
            const content = document.querySelector('.content');

            const heroGrid = document.getElementById('hero-grid');
            const startButton = document.getElementById('start-button');

            document.querySelectorAll('.collapsible').forEach(button => {
              button.addEventListener('click', () => {
                button.classList.toggle('active');
                const content = button.nextElementSibling;
                if (content) content.classList.toggle('show');
              });
            });

            // Sort and filter heroes
            const filteredHeroes = heroes
                .filter(h => h.doNotShow !== "true")
                .sort((a, b) => {
                const order = { Guardian: 1, Striker: 2, Tactician: 3 };
                if (order[a.category] !== order[b.category]) return order[a.category] - order[b.category];
                return parseInt(a.id) - parseInt(b.id);
                });

            const categories = [
                { name: 'Guardian', class: 'guardian-bg' },
                { name: 'Striker', class: 'striker-bg' },
                { name: 'Tactician', class: 'tactician-bg' }
            ];

            // Render categories with wrapping grids
            categories.forEach(cat => {
                const catHeroes = filteredHeroes.filter(h => h.category === cat.name);
                if (!catHeroes.length) return;

                const section = document.createElement('div');
                section.classList.add('category-group', cat.class);

                const title = document.createElement('div');
                title.classList.add('hero-category-title');

                // Count only heroes that are not doNotShow:true
                const visibleCount = catHeroes.filter(h => h.doNotShow !== "true").length;

                // Add an 's' for pluralized category names
                title.textContent = `${cat.name}s (${visibleCount})`;

                section.appendChild(title);

                catHeroes.forEach(hero => {
                const card = document.createElement('div');
                card.classList.add('hero-card');
                card.dataset.id = hero.id;

                const img = document.createElement('img');
                img.src = hero.image;
                img.alt = hero.name;

                const name = document.createElement('p');
                name.textContent = hero.name;

                const badge = document.createElement('span');
                badge.className = 'selection-badge';
                badge.textContent = '';

                const wrapper = document.createElement('div');
                wrapper.className = 'hero-image-wrapper';
                wrapper.appendChild(img);
                wrapper.appendChild(badge);

                card.appendChild(wrapper);
                card.appendChild(name);
                section.appendChild(card);
                });

                heroGrid.appendChild(section);
            });

            // Keep ordered selection
            let selectedOrder = [];

            // Paint all badges and selected styles based on selectedOrder
            function updateBadges() {
              document.querySelectorAll('.hero-card').forEach(card => {
                const id = card.dataset.id;
                const idx = selectedOrder.indexOf(id);
                const badge = card.querySelector('.selection-badge');

                if (idx > -1) {
                  card.classList.add('selected');
                  if (badge) {
                    badge.style.display = 'flex';
                    badge.textContent = String(idx + 1);
                  }
                } else {
                  card.classList.remove('selected');
                  if (badge) {
                    badge.style.display = 'none';
                    badge.textContent = '';
                  }
                }
              });
            }

            heroGrid.addEventListener('click', e => {
              const card = e.target.closest('.hero-card');
              if (!card) return;

              const heroId = card.dataset.id;
              const idx = selectedOrder.indexOf(heroId);

              if (idx > -1) {
                // Deselect: remove and reindex others
                selectedOrder.splice(idx, 1);
              } else if (selectedOrder.length < 6) {
                // Select: append to the end; order matters
                selectedOrder.push(heroId);
              }

              updateBadges();
              updateStartButton();
            });

            // Encrypt data using AES-GCM with SHA-256–derived key
            async function encryptData(data, secretKey) {
              const enc = new TextEncoder();
              const iv = crypto.getRandomValues(new Uint8Array(12));

              // Derive a 256-bit key from any secret string
              const keyMaterial = await crypto.subtle.digest("SHA-256", enc.encode(secretKey));
              const key = await crypto.subtle.importKey(
                "raw",
                keyMaterial,
                { name: "AES-GCM" },
                false,
                ["encrypt"]
              );

              const encoded = enc.encode(JSON.stringify(data));
              const cipherBuffer = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, encoded);

              // Combine IV + ciphertext → base64
              const combined = new Uint8Array(iv.length + cipherBuffer.byteLength);
              combined.set(iv);
              combined.set(new Uint8Array(cipherBuffer), iv.length);
              return btoa(String.fromCharCode(...combined));
            }

            startButton.addEventListener("click", async () => {
              if (!startButton.classList.contains("active")) return;

              const SECRET = "GeimonHeroKey42";
              const payload = {
                heroes: selectedOrder,
                overlords: selectedOverlords,
                tactics: selectedTactics
              };

              const encrypted = await encryptData(payload, SECRET);
              const url = new URL("game.html", window.location.origin);
              url.searchParams.set("data", encrypted);
              window.location.href = url.toString();
            });

            // --- Randomization and Loadout Management ---
            let undoStack = [];
            let redoStack = [];

            // Utility: get all hero IDs not yet chosen
            function getUnselectedHeroes() {
              const allIds = Array.from(document.querySelectorAll('.hero-card')).map(c => c.dataset.id);
              return allIds.filter(id => !selectedOrder.includes(id));
            }

            // Utility: apply selected order visually
            function applySelection(order) {
              selectedOrder = order.slice();
              updateBadges();
              updateStartButton();
            }

            // Randomly fill remaining slots up to 6
            function randomizeSelection() {
              const maxSelectable = 6 - selectedOrder.length;
              if (maxSelectable <= 0) return;

              const available = getUnselectedHeroes();
              if (available.length === 0) return;

              // Choose a random number of new heroes between 1 and maxSelectable
              const countToAdd = Math.floor(Math.random() * maxSelectable) + 1;
              const toAdd = [];

              while (toAdd.length < countToAdd && available.length > 0) {
                const idx = Math.floor(Math.random() * available.length);
                toAdd.push(available.splice(idx, 1)[0]);
              }

              undoStack.push([...selectedOrder]);  // save pre-random state
              redoStack = [];                      // clear redo on new random
              selectedOrder = [...selectedOrder, ...toAdd];

              updateBadges();
              updateStartButton();
            }

            // Undo last random
            function undoRandom() {
              if (undoStack.length === 0) return;
              redoStack.push([...selectedOrder]);
              const prev = undoStack.pop();
              applySelection(prev);
            }

            // Redo last undone random
            function redoRandom() {
              if (redoStack.length === 0) return;
              undoStack.push([...selectedOrder]);
              const next = redoStack.pop();
              applySelection(next);
            }

            // Export current loadout to a text file
            function exportLoadout() {
              const data = {
                heroes: selectedOrder,
                overlords: selectedOverlords,
                tactics: selectedTactics
              };
              const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
              const url = URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              a.download = 'loadout.json';
              a.click();
              URL.revokeObjectURL(url);
            }


            // Import loadout from user file
            function importLoadout(event) {
              const file = event.target.files[0];
              if (!file) return;

              const reader = new FileReader();
              reader.onload = e => {
                try {
                  const data = JSON.parse(e.target.result);

                  // --- Heroes ---
                  if (Array.isArray(data.heroes)) {
                    selectedOrder = data.heroes.slice(0, 6);
                    updateBadges();
                  }

                  // --- Overlords ---
                  if (Array.isArray(data.overlords)) {
                    selectedOverlords = data.overlords.slice(0, 3);
                    updateOverlordBadges();
                  }

                  // --- Tactics ---
                  if (Array.isArray(data.tactics)) {
                    selectedTactics = data.tactics.slice(0, 2);
                    updateTacticStyles();
                  }

                  updateStartButton();
                } catch (err) {
                  console.error("Failed to import loadout:", err);
                  alert("Invalid file format. Please use a valid .json loadout file.");
                }
              };
              reader.readAsText(file);
            }

            // --- Button bindings ---
            document.getElementById('random-heroes').addEventListener('click', randomizeSelection);
            document.getElementById('undo-random').addEventListener('click', undoRandom);
            document.getElementById('redo-random').addEventListener('click', redoRandom);
            document.getElementById('export-loadout').addEventListener('click', exportLoadout);

            // Create hidden file input for import
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = '.txt';
            fileInput.style.display = 'none';
            fileInput.addEventListener('change', importLoadout);
            document.body.appendChild(fileInput);

            document.getElementById('import-loadout').addEventListener('click', () => fileInput.click());

            // ==================== OVERLORD SECTION ====================
            const overlordGrid = document.getElementById('overlord-grid');
            let selectedOverlords = [];
            let overlordUndoStack = [];
            let overlordRedoStack = [];

            // Filter and group Overlords
            const filteredOverlords = overlords
              .filter(o => String(o.doNotShow).toLowerCase() !== "true")
              .map(o => ({
                ...o,
                level: Number(o.level),
                hp: Number(o.hp)
              }))
              .sort((a, b) => a.level - b.level || a.hp - b.hp);

            // Group by difficulty
            const difficulties = [
              { level: 1, colorClass: 'difficulty-1', label: 'Easy' },
              { level: 2, colorClass: 'difficulty-2', label: 'Medium' },
              { level: 3, colorClass: 'difficulty-3', label: 'Hard' }
            ];

            difficulties.forEach(diff => {
              const section = document.createElement('div');
              section.classList.add('category-group', diff.colorClass);

              const title = document.createElement('div');
              title.classList.add('difficulty-title');
              title.textContent = `Difficulty ${diff.level} (${diff.label})`;
              section.appendChild(title);

              const overlordGroup = filteredOverlords.filter(o => o.level === diff.level);
              overlordGroup.forEach(overlord => {
                const card = document.createElement('div');
                card.classList.add('overlord-card');
                card.dataset.id = overlord.id;
                card.dataset.level = overlord.level;
                card.dataset.hp = overlord.hp;

                const img = document.createElement('img');
                img.src = overlord.image;
                img.alt = overlord.name;

                const name = document.createElement('p');
                name.textContent = overlord.name;

                const hp = document.createElement('p');
                hp.textContent = `${overlord.hp} HP`;

                const badge = document.createElement('span');
                badge.className = 'selection-badge';

                const wrapper = document.createElement('div');
                wrapper.className = 'hero-image-wrapper';
                wrapper.appendChild(img);
                wrapper.appendChild(badge);

                card.appendChild(wrapper);
                card.appendChild(name);
                card.appendChild(hp);
                section.appendChild(card);
              });

              overlordGrid.appendChild(section);
            });

            // Update visuals
            function updateOverlordBadges() {
              document.querySelectorAll('.overlord-card').forEach(card => {
                const id = card.dataset.id;
                const idx = selectedOverlords.indexOf(id);
                const badge = card.querySelector('.selection-badge');

                if (idx > -1) {
                  card.classList.add('selected');
                  if (badge) {
                    badge.style.display = 'flex';
                    badge.textContent = String(idx + 1);
                  }
                } else {
                  card.classList.remove('selected');
                  if (badge) {
                    badge.style.display = 'none';
                    badge.textContent = '';
                  }
                }
              });
            }

            // Handle click
            overlordGrid.addEventListener('click', e => {
              const card = e.target.closest('.overlord-card');
              if (!card) return;
              const id = card.dataset.id;
              const idx = selectedOverlords.indexOf(id);

              if (idx > -1) {
                selectedOverlords.splice(idx, 1);
              } else if (selectedOverlords.length < 3) {
                selectedOverlords.push(id);
              }

              // Sort by difficulty, then HP
              const overlordData = overlords.filter(o => selectedOverlords.includes(String(o.id)));
              overlordData.sort((a, b) => a.level - b.level || a.hp - b.hp);
              selectedOverlords = overlordData.map(o => String(o.id));

              updateOverlordBadges();
              updateStartButton();
            });

            // Randomize Overlords
            function randomizeOverlords() {
              const maxSelectable = 3 - selectedOverlords.length;
              if (maxSelectable <= 0) return;

              const available = filteredOverlords
                .filter(o => !selectedOverlords.includes(String(o.id)));
              if (available.length === 0) return;

              const countToAdd = Math.max(1, Math.ceil(Math.random() * maxSelectable));
              const toAdd = [];

              while (toAdd.length < countToAdd && available.length > 0) {
                const idx = Math.floor(Math.random() * available.length);
                toAdd.push(available.splice(idx, 1)[0]);
              }

              overlordUndoStack.push([...selectedOverlords]);
              overlordRedoStack = [];

              const newSelection = [...selectedOverlords, ...toAdd.map(o => String(o.id))];
              const ordered = overlords
                .filter(o => newSelection.includes(String(o.id)))
                .sort((a, b) => a.level - b.level || a.hp - b.hp);
              selectedOverlords = ordered.map(o => String(o.id));

              updateOverlordBadges();
              updateStartButton();
            }

            function undoOverlords() {
              if (overlordUndoStack.length === 0) return;
              overlordRedoStack.push([...selectedOverlords]);
              selectedOverlords = overlordUndoStack.pop();
              updateOverlordBadges();
              updateStartButton();
            }

            function redoOverlords() {
              if (overlordRedoStack.length === 0) return;
              overlordUndoStack.push([...selectedOverlords]);
              selectedOverlords = overlordRedoStack.pop();
              updateOverlordBadges();
              updateStartButton();
            }

            // Button bindings
            document.getElementById('random-overlords').addEventListener('click', randomizeOverlords);
            document.getElementById('undo-overlords').addEventListener('click', undoOverlords);
            document.getElementById('redo-overlords').addEventListener('click', redoOverlords);

            // ==================== TACTICS SECTION ====================
            const tacticsGrid = document.getElementById('tactics-grid');
            let selectedTactics = [];
            let tacticsUndoStack = [];
            let tacticsRedoStack = [];

            // Filter and sort tactics alphabetically, ignoring doNotShow:true
            const filteredTactics = tactics
              .filter(t => String(t.doNotShow).toLowerCase() !== "true")
              .sort((a, b) => a.name.localeCompare(b.name));

            // Render tactics
            filteredTactics.forEach(t => {
              const card = document.createElement('div');
              card.classList.add('tactic-card');
              card.dataset.id = t.id;

              const title = document.createElement('h3');
              title.textContent = t.name;

              const desc = document.createElement('div');
              desc.innerHTML = t.abilitiesText
                ?.map(a => a.text)
                .join('<br><br>') || 'No effect listed.';
              desc.style.fontSize = '0.9rem';
              desc.style.marginTop = '5px';

              card.appendChild(title);
              card.appendChild(desc);
              tacticsGrid.appendChild(card);
            });

            // Update visuals
            function updateTacticStyles() {
              document.querySelectorAll('.tactic-card').forEach(card => {
                const id = card.dataset.id;
                if (selectedTactics.includes(id)) {
                  card.classList.add('selected');
                } else {
                  card.classList.remove('selected');
                }
              });
            }

            function updateStartButton() {
              const heroesValid = selectedOrder.length >= 1 && selectedOrder.length <= 6;
              const overlordsValid = selectedOverlords.length >= 1 && selectedOverlords.length <= 3;
              const tacticsValid = selectedTactics.length >= 1 && selectedTactics.length <= 2;

              if (heroesValid && overlordsValid && tacticsValid) {
                startButton.classList.add('active');
                startButton.style.cursor = 'pointer';
              } else {
                startButton.classList.remove('active');
                startButton.style.cursor = 'not-allowed';
              }
            }

            // Handle click selection
            tacticsGrid.addEventListener('click', e => {
              const card = e.target.closest('.tactic-card');
              if (!card) return;
              const id = card.dataset.id;
              const idx = selectedTactics.indexOf(id);

              if (idx > -1) {
                selectedTactics.splice(idx, 1);
              } else if (selectedTactics.length < 2) {
                selectedTactics.push(id);
              }

              updateTacticStyles();
              updateStartButton();
            });

            // Randomize Tactics
            function randomizeTactics() {
              const maxSelectable = 2 - selectedTactics.length;
              if (maxSelectable <= 0) return;

              const available = filteredTactics.filter(t => !selectedTactics.includes(String(t.id)));
              if (available.length === 0) return;

              const countToAdd = Math.floor(Math.random() * maxSelectable) + 1;
              const toAdd = [];

              while (toAdd.length < countToAdd && available.length > 0) {
                const idx = Math.floor(Math.random() * available.length);
                toAdd.push(available.splice(idx, 1)[0]);
              }

              tacticsUndoStack.push([...selectedTactics]);
              tacticsRedoStack = [];

              selectedTactics = [...selectedTactics, ...toAdd.map(t => String(t.id))];
              updateTacticStyles();
              updateStartButton();
            }

            function undoTactics() {
              if (tacticsUndoStack.length === 0) return;
              tacticsRedoStack.push([...selectedTactics]);
              selectedTactics = tacticsUndoStack.pop();
              updateTacticStyles();
              updateStartButton();
            }

            function redoTactics() {
              if (tacticsRedoStack.length === 0) return;
              tacticsUndoStack.push([...selectedTactics]);
              selectedTactics = tacticsRedoStack.pop();
              updateTacticStyles();
              updateStartButton();
            }

            // Add button bindings
            document.getElementById('random-tactics').addEventListener('click', randomizeTactics);
            document.getElementById('undo-tactics').addEventListener('click', undoTactics);
            document.getElementById('redo-tactics').addEventListener('click', redoTactics);

            const limits = {
              heroes: { min: 1, max: 6 },
              overlords: { min: 1, max: 3 },
              tactics: { min: 1, max: 2 }
            };

            function topRandom() {
              if (selectedOrder.length < limits.heroes.min) randomizeSelection();
              if (selectedOverlords.length < limits.overlords.min) randomizeOverlords();
              if (selectedTactics.length < limits.tactics.min) randomizeTactics();

              // Update visuals for all
              updateBadges();
              updateOverlordBadges();
              updateTacticStyles();
              updateStartButton();
            }
            document.getElementById('top-random').addEventListener('click', topRandom);
        </script>
    </body>
</html>