<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover">
    <link href='https://fonts.googleapis.com/css?family=Racing Sans One' rel='stylesheet'>
    <link rel="icon" href="/favicon.png">
    <link rel="icon" href="https://raw.githubusercontent.com/over-lords/overlords/4c614c1ffe5a9d7194202bd24fae5e7c99d86333/Public/Images/Site%20Assets/favicon.png" type="image/png">
    <link rel="stylesheet" href="style.css">
    <title>Overlords</title>
        <style>
            .bottom-space {
                display:block;
                margin:20px 0;
            }

            .tab-buttons {
                margin-top: 14px;
                display: flex;
                gap: 10px;
            }
            .tab-button {
                border: 5px solid rgb(0, 0, 0);
                background-color: rgb(205, 199, 243);
                color: black;
                padding: 10px 10px;
                text-align: center;
                font-weight: bold;
                text-decoration: none;
                display: inline-block;
                font-family: 'Arial';
                font-size: 12px;
                margin: 4px 2px;
                cursor: pointer;
                table-layout: fixed;
                border-collapse: collapse;
                width: auto;
                border-radius: 10px;
                flex: 0 0 auto;
                white-space: nowrap;
            }
            .tab-button.active {
                background-color: rgb(159, 145, 253);
            }

            .text-body {
                font-family: 'Times New Roman';
            }
            body, h2, h3, h4, h5, h6, text-body {
                font-size: 0.95em !important;
            }
            .card-holder,
            .card-holder * {
                transform-origin: top left !important;
            }
            .card-holder {
                display: inline-block;
                overflow: hidden;
                position: relative;
            }
            .card-holder .card-scale {
                transform-origin: top left;
            }
            .card-holder .card {
                box-sizing: border-box;
            }

            .scale60 {
                width: calc(230px * 0.6);
                height: calc(350px * 0.6);
            }
            .scale60 .card-scale {
                width: 230px;
                height: 350px;
                transform: scale(0.6);
                transform-origin: top left !important;
            }

            #card-search-wrapper {
                width: 80%;
                margin: 10px auto 15px;
                display: flex;
                justify-content: center;
                position: relative;
            }
            #card-search {
                width: 100%;
                padding: 10px 36px 10px 14px;
                font-size: 1rem;
                border-radius: 8px;
                border: 2px solid black;
            }

            .scroll-tabs {
                overflow-x: auto;
                overflow-y: hidden;         /* prevent vertical scrollbar */
                display: flex;
                flex-wrap: nowrap;          /* never wrap to a new line */
                gap: 4px;

                padding-bottom: 10px;       /* space so scrollbar isn't cramped */
                -webkit-overflow-scrolling: touch; /* iOS momentum scrolling */
                scroll-behavior: smooth;

                /* This is the key for mobile: tell browser horizontal panning is intended */
                touch-action: pan-x;

                /* prevent text selection while swiping */
                user-select: none;
            }

            .tab-button {
                flex: 0 0 auto;
                white-space: nowrap;
            }

            /* Desktop scrollbar visibility/styling */
            .scroll-tabs {
                scrollbar-width: auto;              /* Firefox: show a real scrollbar */
                scrollbar-color: #666 #ddd;         /* Firefox: thumb/track colors */
            }

            /* WebKit scrollbar (Chrome/Edge/Safari) */
            .scroll-tabs::-webkit-scrollbar {
                height: 12px;                       /* make it clearly visible */
            }
            .scroll-tabs::-webkit-scrollbar-track {
                background: #ddd;
                border-radius: 999px;
            }
            .scroll-tabs::-webkit-scrollbar-thumb {
                background: #666;
                border-radius: 999px;
            }
            .scroll-tabs::-webkit-scrollbar-thumb:hover {
                background: #444;
            }

            .card-db-row {
                display: flex;
                align-items: flex-start;
                gap: 20px;
                margin-bottom: 24px;
            }
            .card-db-info {
                flex: 1;
                border: 2px solid black;
                border-radius: 8px;
                padding: 10px 14px;
                font-family: Arial, sans-serif;
                font-size: 0.9rem;
                background-color: rgba(255,255,255,.75);
            }
            .card-db-info h4 {
                margin: 4px 0;
            }

            .keyword-block {
                margin-top: 10px;
                padding-top: 8px;
                border-top: 1px solid #999;
                font-size: 0.85rem;
            }

            #categories {
                min-height: 50vh; /* or any stable value */
            }

            #card-list {
                padding: 0 10px 10px;
            }

            .tab-strip-wrap{
                position: relative;
            }

            /* The scrollable bar stays as-is */
            #filters.scroll-tabs{
                overflow-x: auto;
                overflow-y: hidden;
                display: flex;
                flex-wrap: nowrap;
                gap: 10px;
                padding: 8px 44px; /* reserve space so arrows don't cover buttons */
            }

            /* Base arrow button */
            .tab-scroll-btn{
                position: absolute;
                top: 50%;
                transform: translateY(-50%);
                margin-top: -5px;
                z-index: 5000;

                width: 32px;
                height: 64px;
                border: 2px solid black;
                background: rgba(255,255,255,0.9);

                display: flex;
                align-items: center;
                justify-content: center;

                font-size: 28px;
                font-weight: bold;
                line-height: 1;
                cursor: pointer;

                user-select: none;
            }

            /* Left: half circle (pill) that juts into view */
            .tab-scroll-left{
                left: 0;
                border-radius: 0 999px 999px 0;
                border-left: none; /* so it looks like it emerges from screen edge */
            }

            /* Right: half circle (pill) that juts into view */
            .tab-scroll-right{
                right: 0;
                border-radius: 999px 0 0 999px;
                border-right: none;
            }

            .tab-scroll-btn:active{
                transform: translateY(-50%) scale(0.98);
            }

            #subfilter-strip{
                margin-top: 8px;
            }

            /* Reserve space so arrows don't cover subfilter buttons (same as main bar) */
            #subfilters.scroll-tabs{
                gap: 10px;
                padding: 8px 44px;
            }

            /* Half-pill arrows for subfilter strip (same shape as main arrows) */
            .sub-scroll-left{
                left: 0;
                border-radius: 0 999px 999px 0;
                border-left: none;
            }
            .sub-scroll-right{
                right: 0;
                border-radius: 999px 0 0 999px;
                border-right: none;
            }

            #card-search-wrapper {
                position: relative;
            }

            #card-search {
                padding-right: 36px; /* room for X */
            }

            #clear-search {
                position: absolute;
                right: 14px;
                top: 50%;
                transform: translateY(-50%);
                border: none;
                background: none;
                font-size: 18px;
                cursor: pointer;
                color: #666;
                display: none;
            }

            #clear-search:hover {
                color: #000;
            }

        </style>
</head>
<body style="background-color:white;">
    <div class="bg-image" alt="" style="opacity: 35%;"></div>
        <div class="title-box" id="title-box" style="margin-top: -15px;"></div>
        <h1 id="title-namePlate" class="glow-red" style="pointer-events: none; font-size: 2.8rem; margin-top: 10px;">Card Database</h1>

        <div id="close-box" onclick="location.href='deckList.html'" style="font-size: 3.5em !important;">X</div>

        <br><br><br><br><br><br>

        <div id="card-search-wrapper">
            <input id="card-search" type="text"
                placeholder="Search cards by name, ability, or keyword…"/>
            <button id="clear-search" type="button" aria-label="Clear search">✕</button>
        </div>

        <div class="tab-strip-wrap">
            <button class="tab-scroll-btn tab-scroll-left" type="button" aria-label="Scroll tabs left">‹</button>
                <div class="tab-buttons scroll-tabs" id="filters">
                    <button class="tab-button active" data-filter="all">All Cards</button>
                    <button class="tab-button" data-filter="overlords">Overlords</button>
                    <button class="tab-button" data-filter="tactics">Tactics</button>
                    <button class="tab-button" data-filter="scenarios">Scenarios</button>
                    <button class="tab-button" data-filter="villains">Villains</button>
                    <button class="tab-button" data-filter="henchmen">Henchmen</button>
                    <button class="tab-button" data-filter="heroes">Heroes</button>
                    <button class="tab-button" data-filter="action">Actions</button>
                    <button class="tab-button" data-filter="allies">Allies</button>
                    <button class="tab-button" data-filter="enemies">Enemies</button>
                    <button class="tab-button" data-filter="bystanders">Bystanders</button>
                </div>
            <button class="tab-scroll-btn tab-scroll-right" type="button" aria-label="Scroll tabs right">›</button>
        </div>

        <div class="tab-strip-wrap" id="subfilter-strip" style="display:none;">
            <button class="tab-scroll-btn sub-scroll-left" type="button" aria-label="Scroll subfilters left">‹</button>

            <div class="tab-buttons scroll-tabs" id="subfilters">
                <!-- JS will inject buttons here -->
            </div>

            <button class="tab-scroll-btn sub-scroll-right" type="button" aria-label="Scroll subfilters right">›</button>
        </div>

        <br>

        <div id="categories">
            <div id="card-list"></div>
        </div>

        <script type="module">
            import { heroes } from './data/faceCards.js';
            import { heroCards } from './data/heroCards.js';
            import { bystanders } from './data/bystanders.js';
            import { enemies } from './data/enemies.js';
            import { allies } from './data/allies.js';
            import { henchmen } from './data/henchmen.js';
            import { overlords } from './data/overlords.js';
            import { scenarios } from './data/scenarios.js';
            import { tactics } from './data/tactics.js';
            import { villains } from './data/villains.js';
            import { renderCard, renderAbilityText } from './utils/cardRenderer.js';
            import { keywords } from './data/keywords.js';

            const subfilterBar = document.getElementById("subfilters");

            export function findAnyCardById(id) {
                const dataSources = [
                    heroes,
                    heroCards,
                    villains,
                    henchmen,
                    bystanders,
                    enemies,
                    allies,
                    overlords,
                    tactics,
                    scenarios
                ];

                for (const source of dataSources) {
                    if (!Array.isArray(source)) continue;
                    const match = source.find(c => c.id == id);
                    if (match) return match;
                }
                return null;
            }

            export function printCardAnywhere(id, targetSelector) {
                const cardData = findAnyCardById(id);

                if (!cardData) {
                    console.warn(`Card with id ${id} not found in ANY data file.`);
                    return;
                }

                const target = document.querySelector(targetSelector);
                if (!target) {
                    console.warn(`printCardAnywhere(): Cannot find target element ${targetSelector}`);
                    return;
                }

                // Use your existing renderCard()
                const rendered = renderCard(cardData.id);

                target.appendChild(rendered);
            }

            function renderCardInfo(card) {
                let html = "";

                const a = card.abilitiesText || [];

                switch (card.type) {
                    case "Henchman":
                    case "Villain":
                    html += `<h4>${card.name}</h4>`;
                    html += `<div>HP: ${card.hp}</div>`;
                    html += `<div>Damage: ${card.damage}</div>`;
                    break;

                    case "Bystander":
                    html += `<h4>${card.name}</h4>`;
                    break;

                    case "Main":
                    html += `<h4>${card.name}</h4>`;
                    html += `<div>Damage: ${card.damage}</div>`;
                    html += `<div>Copies in Deck: ${card.perDeck}</div>`;
                    break;

                    case "Ally":
                    case "Enemy":
                    html += `<h4>${card.name}</h4>`;
                    break;

                    case "Hero":
                    html += `<h4>${card.name}</h4>`;
                    html += `<div>HP: ${card.hp}</div>`;
                    html += `<div>Damage Threshold: ${card.damageThreshold}</div>`;
                    html += `<div>Travel: ${card.travel}</div>`;
                    html += `<div>Retreat: ${card.retreat}</div>`;
                    break;

                    case "Overlord":
                    case "Scenario":
                    html += `<h4>${card.name}</h4>`;
                    html += `<div>HP: ${card.hp}</div>`;
                    break;

                    case "Tactic":
                    html += `<h4>${card.name}</h4>`;
                    break;
                }

                if (a.length) {
                    html += `<hr>`;
                    a.forEach(x => {
                        html += `<div>${renderAbilityText(x.text)}</div>`;
                    });
                }

                return html;
            }

            function extractKeywordsFromAbilities(abilitiesTextArr) {
                if (!Array.isArray(abilitiesTextArr)) return [];

                const found = new Set();

                const keywordNames = Object.keys(keywords); // from keywords.js

                abilitiesTextArr.forEach(a => {
                    if (!a || !a.text) return;

                    keywordNames.forEach(kw => {
                        const regex = new RegExp(`(^|[^A-Za-z0-9'])${kw}([^A-Za-z0-9']|$)`, "i");
                        if (regex.test(a.text)) {
                            found.add(kw);
                        }
                    });
                });

                return Array.from(found);
            }

            function buildTab(containerId, cards) {
                const container = document.getElementById(containerId);
                container.innerHTML = "";

                const search = document.getElementById("card-search").value.toLowerCase();

                cards
                    .filter(card => card.doNotShow !== "true")
                    .slice()
                    .sort((a, b) => a.name.localeCompare(b.name))
                    .filter(card => {
                        if (!search) return true;
                        const text =
                            card.name +
                            JSON.stringify(card.abilitiesText || []) +
                            extractKeywordsFromAbilities(card.abilitiesText || []).join(" ");
                        return text.toLowerCase().includes(search);
                    })
                    .forEach(card => {
                    const row = document.createElement("div");
                    row.className = "card-db-row";

                    const cardWrap = document.createElement("div");
                    cardWrap.className = "card-holder scale60";
                    const rendered = renderCard(card.id);

                    // Create scale wrapper EXPECTED by your CSS
                    const scale = document.createElement("div");
                    scale.className = "card-scale";

                    // Move the actual card into the scale wrapper
                    scale.appendChild(rendered);

                    // Mount properly
                    cardWrap.appendChild(scale);

                    const info = document.createElement("div");
                    info.className = "card-db-info";
                    info.innerHTML = renderCardInfo(card);

                    const foundKeys = extractKeywordsFromAbilities(card.abilitiesText || [])
                        .sort((a, b) => a.localeCompare(b));

                    if (foundKeys.length > 0) {
                        const kwBox = document.createElement("div");
                        kwBox.className = "keyword-block";

                        const title = document.createElement("div");
                        title.style.fontWeight = "bold";
                        title.style.fontSize = "1rem";
                        title.textContent = "Keywords";
                        kwBox.appendChild(title);

                        foundKeys.forEach(k => {
                            const def = keywords[k] || "No definition found.";
                            const line = document.createElement("div");
                            line.style.marginTop = "4px";
                            line.innerHTML = `<span style="font-weight:600;">${k}: </span>${def}`;
                            kwBox.appendChild(line);
                        });

                        info.appendChild(kwBox);
                    }

                    row.append(cardWrap, info);
                    container.appendChild(row);
                });
            }

            const ALL = [
                ...heroes,
                ...heroCards,
                ...villains,
                ...henchmen,
                ...bystanders,
                ...enemies,
                ...allies,
                ...overlords,
                ...tactics,
                ...scenarios,
                ];

            let activeFilter = "all";

            const FILTERS = {
            all: ALL,
            heroes: heroes,
            action: heroCards,
            villains: villains,
            henchmen: henchmen,
            bystanders: bystanders,
            allies: allies,
            enemies: enemies,
            overlords: overlords,
            tactics: tactics,
            scenarios: scenarios
            };

            let activeSubfilter = "all";

            const SUBFILTER_CONFIG = {
            action:   { label: "Hero",     key: "hero",     sort: (a,b) => a.localeCompare(b) }, // Actions by hero
            heroes:   { label: "Category", key: "category", sort: (a,b) => a.localeCompare(b) }, // Heroes by category
            henchmen: { label: "HP",       key: "hp",       sort: (a,b) => Number(a) - Number(b) }, // Henchmen by hp
            overlords:{ label: "Level",    key: "level",    sort: (a,b) => Number(a) - Number(b) }, // Overlords by level
            villains: { label: "Hero",     key: "hero",     sort: (a,b) => a.localeCompare(b) }, // Villains by hero
            };

            function getSubfilterValues(cards, key, sortFn) {
                let working = cards;

                if (activeFilter === "action") {
                    working = cards.filter(c => isHeroVisibleByName(c.hero));
                }

                const vals = working
                    .map(c => c?.[key])
                    .filter(v => typeof v === "string" && v.trim().length > 0)
                    .map(v => v.trim());

                const uniq = Array.from(new Set(vals));
                uniq.sort(sortFn);

                return ["all", ...uniq];
            }

            function buildSubfilterStrip() {
                const strip = document.getElementById("subfilter-strip");
                const bar   = document.getElementById("subfilters");

                const cfg = SUBFILTER_CONFIG[activeFilter];
                if (!cfg) {
                    // Hide when not applicable
                    activeSubfilter = "all";
                    strip.style.display = "none";
                    bar.innerHTML = "";
                    return;
                }

                // Show when applicable
                strip.style.display = "block";
                requestAnimationFrame(updateSubfilterScrollBtns);

                const baseCards = FILTERS[activeFilter] || [];
                const values = getSubfilterValues(baseCards, cfg.key, cfg.sort);

                // If the current activeSubfilter no longer exists, reset to all
                if (!values.includes(activeSubfilter)) activeSubfilter = "all";

                // Render buttons
                bar.innerHTML = "";
                values.forEach(v => {
                    const btn = document.createElement("button");
                    btn.className = "tab-button" + (v === activeSubfilter ? " active" : "");
                    btn.dataset.subfilter = v;

                    // Button text: "All" then the value (and optionally label prefix)
                    if (v === "all") {
                    btn.textContent = "All";
                    } else {
                    btn.textContent = v;
                    }

                    bar.appendChild(btn);
                });

                // Reset scroll position when switching main filters
                bar.scrollLeft = 0;
            }


            function applySubfilter(cards) {
                if (activeSubfilter === "all") return cards;

                const cfg = SUBFILTER_CONFIG[activeFilter];
                if (!cfg) return cards;

                const key = cfg.key;
                return cards.filter(c => String(c?.[key] ?? "").trim() === activeSubfilter);
            }

            function renderFilteredList() {
                let cards = FILTERS[activeFilter] || [];

                if (activeFilter === "action") {
                    cards = cards.filter(c => isHeroVisibleByName(c.hero));
                }

                const subFiltered = applySubfilter(cards);
                buildTab("card-list", subFiltered);
            }

            // Filter button click handling (event delegation)
            document.getElementById("filters").addEventListener("click", (e) => {
                const btn = e.target.closest("button[data-filter]");
                if (!btn) return;

                // update active button styling
                document.querySelectorAll("#filters .tab-button").forEach(b => b.classList.remove("active"));
                btn.classList.add("active");

                // update filter and re-render
                activeFilter = btn.dataset.filter;

                // reset subfilter whenever main filter changes
                activeSubfilter = "all";

                // build (or hide) the subfilter strip for this filter
                buildSubfilterStrip();

                // render list with new filters
                renderFilteredList();

                saveUIState();
            });

            (function clearStateOnFreshEnter(){
                const navEntry = performance.getEntriesByType?.("navigation")?.[0];
                const navType = navEntry?.type; // "navigate" | "reload" | "back_forward" | "prerender"

                // Treat anything except an explicit reload as a "fresh enter"
                const isReload = (navType === "reload");

                if (!isReload) {
                    localStorage.removeItem("cardDBState");
                }
            })();

            if (!localStorage.getItem("cardDBState")) {
                buildSubfilterStrip();
                renderFilteredList();
            }

            const filterBar = document.getElementById("filters");

            document.querySelector(".tab-scroll-left").addEventListener("click", () => {
                filterBar.scrollBy({ left: -500, behavior: "smooth" });
            });

            document.querySelector(".tab-scroll-right").addEventListener("click", () => {
                filterBar.scrollBy({ left: 500, behavior: "smooth" });
            });

            function updateTabScrollBtns(){
                const max = filterBar.scrollWidth - filterBar.clientWidth;
                document.querySelector(".tab-scroll-left").style.display = (filterBar.scrollLeft <= 2) ? "none" : "flex";
                document.querySelector(".tab-scroll-right").style.display = (filterBar.scrollLeft >= max - 2) ? "none" : "flex";
            }
            filterBar.addEventListener("scroll", () => {
                updateTabScrollBtns();
                scheduleScrollSave();
            });
            window.addEventListener("resize", updateTabScrollBtns);
            updateTabScrollBtns();

            document.getElementById("subfilters").addEventListener("click", (e) => {
                const btn = e.target.closest("button[data-subfilter]");
                if (!btn) return;

                document.querySelectorAll("#subfilters .tab-button").forEach(b => b.classList.remove("active"));
                btn.classList.add("active");

                activeSubfilter = btn.dataset.subfilter;
                renderFilteredList();
                saveUIState();
            });

            document.querySelector(".sub-scroll-left").addEventListener("click", () => {
            subfilterBar.scrollBy({ left: -400, behavior: "smooth" });
            });

            document.querySelector(".sub-scroll-right").addEventListener("click", () => {
            subfilterBar.scrollBy({ left: 400, behavior: "smooth" });
            });

            function updateSubfilterScrollBtns() {
                const strip = document.getElementById("subfilter-strip");
                if (!strip || strip.style.display === "none") return;

                const max = subfilterBar.scrollWidth - subfilterBar.clientWidth;

                document.querySelector(".sub-scroll-left").style.display =
                    (subfilterBar.scrollLeft <= 2) ? "none" : "flex";

                document.querySelector(".sub-scroll-right").style.display =
                    (subfilterBar.scrollLeft >= max - 2) ? "none" : "flex";
            }

            subfilterBar.addEventListener("scroll", () => {
                updateSubfilterScrollBtns();
                scheduleScrollSave();
            });

            window.addEventListener("resize", updateSubfilterScrollBtns);

            function isHeroVisibleByName(heroName) {
                if (!heroName) return false;

                const hero = heroes.find(
                    h => h.name && h.name.toLowerCase() === heroName.toLowerCase()
                );

                // If hero not found, fail closed
                if (!hero) return false;

                return hero.doNotShow !== "true";
            }

            function getUIState() {
                return {
                    filter: activeFilter,
                    subfilter: activeSubfilter,
                    search: document.getElementById("card-search")?.value || "",
                    mainScroll: document.getElementById("filters")?.scrollLeft || 0,
                    subScroll: document.getElementById("subfilters")?.scrollLeft || 0,
                    pageScroll: window.scrollY || 0
                };
            }

            function saveUIState() {
                const state = getUIState();
                localStorage.setItem("cardDBState", JSON.stringify(state));
            }


            const searchInput = document.getElementById("card-search");
            const clearSearchBtn = document.getElementById("clear-search");

            searchInput.addEventListener("input", () => {
                clearSearchBtn.style.display = searchInput.value ? "block" : "none";
                renderFilteredList();
                saveUIState();
            });

            clearSearchBtn.addEventListener("click", () => {
                searchInput.value = "";
                clearSearchBtn.style.display = "none";
                renderFilteredList();
                saveUIState();
            });


            let scrollSaveScheduled = false;

            function scheduleScrollSave() {
                if (scrollSaveScheduled) return;
                scrollSaveScheduled = true;

                requestAnimationFrame(() => {
                    scrollSaveScheduled = false;
                    saveUIState();
                });
            }

            window.addEventListener("scroll", scheduleScrollSave);


            function restoreUIState() {
                let state = null;

                try {
                    state = JSON.parse(localStorage.getItem("cardDBState"));
                } catch {}

                if (!state) return;

                // Restore search
                document.getElementById("card-search").value = state.search || "";

                document.getElementById("clear-search").style.display =
                    state.search ? "block" : "none";

                // Restore filters
                activeFilter = state.filter || "all";
                activeSubfilter = state.subfilter || "all";

                // Sync button UI
                document.querySelectorAll("#filters .tab-button").forEach(b =>
                    b.classList.toggle("active", b.dataset.filter === activeFilter)
                );

                // Build subfilters BEFORE render
                buildSubfilterStrip();

                document.querySelectorAll("#subfilters .tab-button").forEach(b =>
                    b.classList.toggle("active", b.dataset.subfilter === activeSubfilter)
                );

                // Render list
                renderFilteredList();

                // Restore scroll positions AFTER layout
                requestAnimationFrame(() => {
                    document.getElementById("filters").scrollLeft = state.mainScroll || 0;
                    document.getElementById("subfilters").scrollLeft = state.subScroll || 0;
                    window.scrollTo(0, state.pageScroll || 0);

                    updateTabScrollBtns();
                    updateSubfilterScrollBtns();
                });
            }

            restoreUIState();
        </script>
</body>
</html>