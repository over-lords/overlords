<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover">
    <link href='https://fonts.googleapis.com/css?family=Racing Sans One' rel='stylesheet'>
    <link rel="icon" href="favicon.png">
    <link rel="icon" href="https://raw.githubusercontent.com/over-lords/overlords/4c614c1ffe5a9d7194202bd24fae5e7c99d86333/Public/Images/Site%20Assets/favicon.png" type="image/png">
    <link rel="stylesheet" href="style.css">
    <style>
        #rotator-text-wrapper {
            position: relative;
            width: 100%;
            height: 18px;
            overflow: hidden;
        }
        .rotator-line {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            font-size: 14px;
            line-height: 1.3;
            color: #111;
            text-shadow: 1px 1px 0 #fff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            transform: translateY(-120%);
            opacity: 0;
        }
        .rotator-active {
            transform: translateY(0);
            opacity: 1;
        }
        .rotator-hidden {
            transform: translateY(-120%);
            opacity: 0;
        }
        .rotator-anim-in {
            animation: rotatorSlideIn 0.45s ease forwards;
        }
        .rotator-anim-out {
            animation: rotatorSlideOut 0.45s ease forwards;
        }
        @keyframes rotatorSlideIn {
            from { transform: translateY(-120%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        @keyframes rotatorSlideOut {
            from { transform: translateY(0); opacity: 1; }
            to { transform: translateY(120%); opacity: 0; }
        }
        /* Host start button states */
        #launch-btn {
            background: #b5b5b5;
            border: 4px solid #777;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.25);
            border-radius: 6px;
            pointer-events: none;
            cursor: not-allowed;
            opacity: 0.8;
            transition: all 0.2s ease;
        }
        #launch-btn.clickable {
            background: #ffd54f;
            border-color: #c59b00;
            box-shadow: 0 6px 14px rgba(0,0,0,0.3);
            pointer-events: auto;
            cursor: pointer;
            opacity: 1;
        }
        #launch-btn .menu-text {
            color: #111;
            text-shadow: none;
            font-weight: bold;
            font-size: 20px;
            padding: 10px 18px;
        }
        /* Ready button states */
        #ready-btn {
            background: #b5b5b5;
            border: 4px solid #777;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.25);
            border-radius: 6px;
            pointer-events: none;
            cursor: not-allowed;
            opacity: 0.8;
            transition: all 0.2s ease;
        }
        #ready-btn.clickable {
            background: #ffd54f;
            border-color: #c59b00;
            box-shadow: 0 6px 14px rgba(0,0,0,0.3);
            pointer-events: auto;
            cursor: pointer;
            opacity: 1;
        }
        #ready-btn .menu-text {
            color: #111;
            text-shadow: none;
            font-weight: bold;
            font-size: 20px;
            padding: 10px 18px;
        }
        /* Hero selector rail */
        #hero-selector {
            position: fixed;
            left: 5px;
            top: 75px;
            width: 360px;
            height: 180px;
            overflow-y: auto;
            background: rgba(255,255,255,0.9);
            border: 4px solid #000;
            border-radius: 10px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.25);
            padding: 6px;
            z-index: 11;
        }
        .hero-category-block {
            margin-bottom: 6px;
            border: 2px solid #000;
            border-radius: 8px;
            padding: 4px;
        }
        .hero-category-title {
            font-weight: 700;
            font-size: 14px;
            margin: 0 0 4px 0;
        }
        .hero-card-small {
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            gap: 3px;
            margin: 0 4px 6px 0;
            cursor: pointer;
            position: relative;
            width: 72px;
        }
        .hero-card-small img {
            width: 62px;
            height: 62px;
            object-fit: cover;
            border: 2px solid #000;
            border-radius: 6px;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }
        .hero-card-small.selected img {
            box-shadow: 0 0 10px 4px #ffd54f;
            transform: scale(1.04);
        }
        .hero-card-small .hero-name {
            font-size: 11px;
            font-weight: 700;
            text-align: center;
            line-height: 1.1;
            max-width: 72px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .hero-card-small .hero-badge {
            position: absolute;
            top: -2px;
            right: -2px;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: #ffd54f;
            border: 2px solid #000;
            color: #000;
            display: none;
            align-items: center;
            justify-content: center;
            font-weight: 800;
            font-size: 12px;
        }
    </style>
    <title>Overlords</title>
</head>
<body style="background-color:white;">
    <div class="bg-image" alt="" style="opaCity: 35%;"></div>
    <div class="container">
        <div class="title-box" id="title-box" style="margin-top: -30px;"></div>
        <h1 class="glow-red" style="pointer-events: none;"><div id="privacy-readout" style="font-size: 3rem;"></div></h1>

        <div id="close-box" onclick="location.href='multi.html'">X</div>

        <div id="launch-btn" style="display: none; cursor: pointer; position: fixed; left: 170px; bottom: 5px; z-index: 12; margin: 0;">
            <h1 class="menu-text" style="margin: 0; pointer-events: none;">Start Game</h1>
        </div>

        <div id="ready-btn" style="cursor: pointer; position: fixed; left: 5px; bottom: 5px; z-index: 12; margin: 0;">
            <h1 class="menu-text" style="margin: 0; pointer-events: none;">Ready</h1>
        </div>

        <div id="hero-selector">
            <div id="hero-grid-lobby"></div>
        </div>

        <br><br><br><br><br><br>

        <div id="player-list-box" style="position: fixed; right: 105px; top: 10px; margin: 0; width: 220px; max-height: 110px; background: #ededed; border: 6px solid #000; border-radius: 10px; box-shadow: 0 6px 18px rgba(0,0,0,0.25); padding: 6px; color: #111; font-family: 'Racing Sans One', sans-serif; display: flex; flex-direction: column; overflow: hidden;">
            <div style="font-size: 14px; font-weight: bold; margin-bottom: 2px; text-shadow: 1px 1px 0 #fff;">Players in Lobby: <span id="player-list-count" style="font-size: 14px;"></span></div>
            <ul id="player-list" style="list-style: none; padding: 0; margin: 0; display: flex; flex-direction: column; gap: 3px; max-height: 100px; overflow-y: auto; padding-right: 4px;"></ul>
        </div>

        <div id="lobby-rotator" style="position: fixed; right: 15px; top: 88%; transform: translateY(-50%); width: 320px; height: 60px; background: #ededed; border: 6px solid #000; border-radius: 10px; box-shadow: 0 6px 18px rgba(0,0,0,0.25); padding: 4px 8px; color: #222; font-family: 'Racing Sans One', sans-serif; pointer-events: none; z-index: 9;">
            <div id="rotator-difficulty" style="font-size: 20px; text-shadow: 1px 1px 0 #fff;">Difficulty:</div>
            <div style="margin-top: 2px; padding: 4px; background: #fff; border: 3px solid #000; border-radius: 6px; min-height: 0px; display: flex; align-items: center; justify-content: flex-start;">
                <div id="rotator-text-wrapper">
                    <div id="rotator-text-a" class="rotator-line rotator-active"></div>
                    <div id="rotator-text-b" class="rotator-line rotator-hidden"></div>
                </div>
            </div>
        </div>

        <div id="join-key-box" style="position: fixed; right: 15px; top: 50%; transform: translateY(-50%); width: 300px; height: 70px; background: #ededed; border: 6px solid black; color: #000; font-family: 'Racing Sans One', sans-serif; box-shadow: 0 4px 12px rgba(0,0,0,0.3); border-radius: 8px; padding: 8px; box-sizing: border-box; display: flex; align-items: center; justify-content: flex-start; text-align: left; pointer-events: auto; z-index: 10; overflow: hidden;">
            <span id="join-key-text" style="font-size: 2.8rem; flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;"></span>
            <button id="join-key-copy" type="button" style="position: absolute; right: -12px; top: 50%; transform: translateY(-50%); height: 44px; padding: 0 14px; border: none; border-radius: 4px; background: #222; color: #fff; font-weight: bold; cursor: pointer; box-shadow: 0 2px 6px rgba(0,0,0,0.25); font-size: 1.5rem; margin-right: 14px; line-height: 50px;">⧉</button>
        </div>
        <div id="join-key-note" style="position: fixed; right: 15px; top: calc(50% + 70px); transform: translateY(-50%); width: 300px; color: #333; font-family: 'Racing Sans One', sans-serif; font-size: 16px; text-align: center; text-shadow: 1px 1px 0 #fff;">Copy and share this key with your friends to join your game!</div>
    </div>

    <script type="module">
        import { supabase } from './supabaseClient.js';
        import { getSessionUserId } from './utils/session.js';
        import { overlords } from './data/overlords.js';
        import { tactics } from './data/tactics.js';
        import { enemies } from './data/enemies.js';
        import { allies } from './data/allies.js';
        import { bystanders } from './data/bystanders.js';
        import { scenarios } from './data/scenarios.js';
        import { henchmen } from './data/henchmen.js';
        import { villains } from './data/villains.js';
        import { heroes } from './data/faceCards.js';

        window.GAME_MODE = "multi";

        async function decrypt(cipherText, secretKey) {
            const data = atob(cipherText);
            const bytes = new Uint8Array([...data].map(c => c.charCodeAt(0)));
            const iv = bytes.slice(0, 12);
            const cipher = bytes.slice(12);

            const keyMaterial = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(secretKey));
            const key = await crypto.subtle.importKey("raw", keyMaterial, { name:"AES-GCM" }, false, ["decrypt"]);

            const decrypted = await crypto.subtle.decrypt({ name:"AES-GCM", iv }, key, cipher);
            return JSON.parse(new TextDecoder().decode(decrypted));
        }

        (async () => {
            const params = new URLSearchParams(window.location.search);
            const encrypted = params.get("data");
            const keyParam = params.get("key") || "";
            const SECRET = "GeimonHeroKey42";
            const playerListEl = document.getElementById("player-list");
            const playerCountEl = document.getElementById("player-list-count");

            if (!encrypted) {
                document.body.insertAdjacentHTML("beforeend","<p style='color:red'>No lobby data found.</p>");
                return;
            }

            let data;
            try {
                data = await decrypt(encrypted, SECRET);
            } catch (e) {
                console.error(e);
                document.body.insertAdjacentHTML("beforeend","<p style='color:red'>Failed to decrypt lobby data.</p>");
                return;
            }
            const apiBase = "https://overlords-app-43e6e621c6d2.herokuapp.com";
            const apiAvailable = !!apiBase;

            let sessionUsername = "Host";
            try {
                const uid = getSessionUserId();
                if (uid) {
                    const { data: user, error } = await supabase
                        .from("users")
                        .select("username")
                        .eq("id", uid)
                        .single();
                    if (user?.username && !error) {
                        sessionUsername = user.username;
                    }
                }
            } catch (e) {
                console.warn("[lobby] Failed to load session username", e);
            }

            let joinKeyVal = data.key || data.joinKey || keyParam || "";

            // Ensure every lobby (even public) has a key so it can be listed/joined
            if (!joinKeyVal) {
                joinKeyVal = Math.random().toString().slice(2, 10);
                data.key = joinKeyVal;
                console.log("[lobby] Generated join key for public lobby", joinKeyVal);
            }

            let readyState = {};
            // Predeclare player collections so async fetch below can write safely
            let currentPlayers = Array.isArray(data.players) && data.players.length ? [...data.players] : [];
            const readyPlayers = new Set();
            const playerSelections = new Map();
            let lobbyHost = data.username || data.host || sessionUsername;
            let serverHost = lobbyHost;
            const getReadyStorageKey = () => joinKeyVal ? `lobbyReady-${joinKeyVal}-${sessionUsername || "anon"}` : null;
            const loadLocalReadyState = () => {
                try {
                    const key = getReadyStorageKey();
                    if (!key) return null;
                    const raw = localStorage.getItem(key);
                    if (!raw) return null;
                    return JSON.parse(raw);
                } catch (e) {
                    console.warn("[lobby] Failed to load local ready state", e);
                    return null;
                }
            };
            const saveLocalReadyState = () => {
                try {
                    const key = getReadyStorageKey();
                    if (!key) return;
                    const selfState = readyState[sessionUsername];
                    if (!selfState) return;
                    localStorage.setItem(key, JSON.stringify(selfState));
                } catch (e) {
                    console.warn("[lobby] Failed to save local ready state", e);
                }
            };
            const decodePlayerEntry = (entry) => {
                if (typeof entry !== "string") return { name: String(entry || ""), heroes: [], ready: false };
                const idx = entry.indexOf("||ready=");
                if (idx === -1) return { name: entry, heroes: [], ready: false };
                const name = entry.slice(0, idx);
                const meta = entry.slice(idx + 2); // skip leading "||"
                const parts = meta.split(";");
                let ready = false;
                let heroes = [];
                parts.forEach(p => {
                    const [k, v] = p.split("=");
                    if (k === "ready") ready = v === "1";
                    if (k === "heroes" && v) heroes = v.split(",").filter(Boolean);
                });
                return { name, heroes, ready };
            };
            const encodePlayerEntry = (name) => {
                const info = readyState[name];
                if (!info || (!info.ready && !(info.heroes || []).length)) return name;
                const heroesStr = Array.isArray(info.heroes) ? info.heroes.join(",") : "";
                const readyFlag = info.ready ? "1" : "0";
                return `${name}||ready=${readyFlag};heroes=${heroesStr}`;
            };
            const decodeAndMergePlayers = (list = []) => {
                const names = [];
                (Array.isArray(list) ? list : []).forEach(entry => {
                    const decoded = decodePlayerEntry(entry);
                    const name = decoded.name || entry;
                    if (!name) return;
                    names.push(name);
                    const hasMeta = decoded.ready || (decoded.heroes && decoded.heroes.length);
                    if (hasMeta) {
                        readyState[name] = {
                            ready: decoded.ready,
                            heroes: decoded.heroes ? decoded.heroes.map(String) : []
                        };
                        if (decoded.ready) readyPlayers.add(name);
                        if (decoded.heroes && decoded.heroes.length) {
                            playerSelections.set(name, decoded.heroes.map(String));
                        }
                    }
                });
                return names;
            };

            // Fetch existing lobby first to capture host/players
            let existingLobby = null;
            if (apiAvailable && joinKeyVal) {
                try {
                    const res = await fetch(`${apiBase}/api/lobbies/${encodeURIComponent(joinKeyVal)}`);
                    if (res.ok) {
                        const json = await res.json();
                        existingLobby = json?.lobby || null;
                        if (existingLobby?.readyState) {
                            readyState = existingLobby.readyState;
                        }
                        if (existingLobby?.host) {
                            lobbyHost = existingLobby.host;
                            serverHost = existingLobby.host;
                        }
                        if (Array.isArray(existingLobby?.players)) {
                            currentPlayers = decodeAndMergePlayers(existingLobby.players);
                        }
                    }
                } catch (e) {
                    console.warn("[lobby] Could not prefetch existing lobby", e);
                }
            }
            const localSelfReady = loadLocalReadyState();
            if (localSelfReady) {
                readyState[sessionUsername] = localSelfReady;
            }

            const existingHost = existingLobby?.host;
            if (existingHost) {
                lobbyHost = existingHost;
                serverHost = existingHost;
            }
            const playerList = Array.isArray(data.players) && data.players.length ? data.players : [lobbyHost];
            if (!currentPlayers.length) {
                currentPlayers = [...playerList];
            }
            const readyBtn = document.getElementById("ready-btn");
            const launchBtn = document.getElementById("launch-btn");
            const heroGridEl = document.getElementById("hero-grid-lobby");
            const isHost = !!(sessionUsername && lobbyHost && sessionUsername === lobbyHost);
            const selectedHeroes = [];
            const overlordMap = new Map(overlords.map(o => [String(o.id), o]));
            const tacticMap   = new Map(tactics.map(t => [String(t.id), t]));
            const enemyMap    = new Map(enemies.map(e => [String(e.id), e]));
            const allyMap     = new Map(allies.map(a => [String(a.id), a]));
            const bystanderMap= new Map(bystanders.map(b => [String(b.id), b]));
            const scenarioMap = new Map(scenarios.map(s => [String(s.id), s]));
            const henchMap    = new Map(henchmen.map(h => [String(h.id), h]));
            const villainMap  = new Map(villains.map(v => [String(v.id), v]));
            const heroMap     = new Map(heroes.map(h => [String(h.id), h]));
            const applyReadyState = (stateObj = {}) => {
                readyPlayers.clear();
                playerSelections.clear();
                Object.entries(stateObj).forEach(([player, info]) => {
                    if (info?.heroes) {
                        playerSelections.set(player, info.heroes);
                    }
                    if (info?.ready) {
                        readyPlayers.add(player);
                    }
                });
                const selfState = stateObj[sessionUsername];
                if (selfState?.heroes?.length) {
                    selectedHeroes.length = 0;
                    selectedHeroes.push(...selfState.heroes.map(String));
                }
                if (readyBtn) {
                    readyBtn.dataset.ready = selfState?.ready ? "true" : "false";
                }
                updateHeroBadges();
                updateReadyButtonState();
                updateStartButtonState();
                saveLocalReadyState();
            };
            const renderPlayers = (list) => {
                if (!playerListEl || !playerCountEl) return;
                const names = decodeAndMergePlayers(list);
                if (names.length) currentPlayers = names;
                const safeList = currentPlayers.filter(Boolean);
                const hostToUse = serverHost || lobbyHost;
                // Ensure host is present at least once
                if (hostToUse && !safeList.includes(hostToUse)) {
                    safeList.unshift(hostToUse);
                }
                // Ensure current session user is listed
                if (sessionUsername && !safeList.includes(sessionUsername)) {
                    safeList.push(sessionUsername);
                }
                playerCountEl.textContent = String(safeList.length);
                playerListEl.innerHTML = "";
                currentPlayers = safeList;
                if (!safeList.length) {
                    const li = document.createElement("li");
                    li.textContent = "No players yet";
                    playerListEl.appendChild(li);
                    return;
                }
                safeList.forEach(name => {
                    const isReadyPlayer = readyPlayers.has(name);
                    const picked = playerSelections.get(name) || [];
                    const heroNames = picked.map(id => heroMap.get(String(id))?.name || id).join(", ");
                    const label = isReadyPlayer && heroNames ? `${name}: ${heroNames}` : name;
                    const li = document.createElement("li");
                    li.textContent = label;
                    li.style.fontSize = "14px";
                    li.style.padding = "2px 4px";
                    li.style.border = "1px solid #ccc";
                    li.style.borderRadius = "6px";
                    li.style.background = isReadyPlayer ? "#c8f7c5" : "#fff";
                    playerListEl.appendChild(li);
                });
                updateStartButtonState();
            };

            const updateHeroBadges = () => {
                if (!heroGridEl) return;
                heroGridEl.querySelectorAll(".hero-card-small").forEach(card => {
                    const id = card.dataset.id;
                    const badge = card.querySelector(".hero-badge");
                    const pos = selectedHeroes.indexOf(id);
                    card.classList.toggle("selected", pos >= 0);
                    if (badge) {
                        badge.textContent = pos >= 0 ? String(pos + 1) : "";
                        badge.style.display = pos >= 0 ? "flex" : "none";
                    }
                });
            };

            const updateReadyButtonState = () => {
                if (!readyBtn) return;
                const hasThree = selectedHeroes.length === 3;
                const isReady = readyBtn.dataset.ready === "true";
                const label = readyBtn.querySelector(".menu-text");
                if (label) label.textContent = isReady ? "Ready!" : "Ready?";
                if (hasThree || isReady) {
                    readyBtn.classList.add("clickable");
                } else {
                    readyBtn.classList.remove("clickable");
                }
            };

            const persistSelfReadyState = () => {
                readyState[sessionUsername] = {
                    ready: readyBtn?.dataset.ready === "true",
                    heroes: [...selectedHeroes]
                };
                saveLocalReadyState();
            };

            const sendReadyState = async () => {
                if (!apiAvailable || !joinKeyVal) return;
                try {
                    await fetch(`${apiBase}/api/lobbies/upsert`, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            key: joinKeyVal,
                            encrypted,
                            isPrivate: data.privacy === true || String(data.privacy).toLowerCase() === "private",
                            difficulty: data.difficulty || "Unknown",
                            host: lobbyHost,
                            players: currentPlayers.map(encodePlayerEntry),
                            readyState
                        })
                    });
                } catch (e) {
                    console.warn("[lobby] Failed to sync ready state", e);
                }
            };

            const updateStartButtonState = () => {
                if (!launchBtn) return;
                const allReady = currentPlayers.every(p => readyPlayers.has(p));
                const enoughPlayers = currentPlayers.length >= 2;
                if (isHost && allReady && enoughPlayers) {
                    launchBtn.classList.add("clickable");
                } else {
                    launchBtn.classList.remove("clickable");
                }
            };

            const toggleHeroSelection = (id) => {
                const idx = selectedHeroes.indexOf(id);
                if (idx >= 0) {
                    selectedHeroes.splice(idx, 1);
                } else {
                    if (selectedHeroes.length >= 3) return;
                    selectedHeroes.push(id);
                }
                if (readyBtn && readyBtn.dataset.ready === "true") {
                    readyBtn.dataset.ready = "false";
                    readyPlayers.delete(sessionUsername);
                    persistSelfReadyState();
                    sendReadyState();
                }
                updateHeroBadges();
                updateReadyButtonState();
                updateStartButtonState();
            };

            const renderHeroSelector = () => {
                if (!heroGridEl) return;
                heroGridEl.innerHTML = "";
                const categories = ["Guardian", "Striker", "Tactician"];
                const labels = { Guardian: "Guardian", Striker: "Striker", Tactician: "Tactician" };
                categories.forEach(cat => {
                    const group = heroes.filter(h => h.type === "Hero" && h.category === cat && String(h.doNotShow).toLowerCase() !== "true");
                    if (!group.length) return;
                    const block = document.createElement("div");
                    block.className = "hero-category-block";
                    const title = document.createElement("div");
                    title.className = "hero-category-title";
                    title.textContent = labels[cat] || cat;
                    block.appendChild(title);
                    group.forEach(h => {
                        const card = document.createElement("div");
                        card.className = "hero-card-small";
                        card.dataset.id = String(h.id);

                        const img = document.createElement("img");
                        img.src = h.image;
                        img.alt = h.name;

                        const name = document.createElement("div");
                        name.className = "hero-name";
                        name.textContent = h.name;

                        const badge = document.createElement("div");
                        badge.className = "hero-badge";

                        card.appendChild(img);
                        card.appendChild(name);
                        card.appendChild(badge);
                        card.addEventListener("click", () => toggleHeroSelection(String(h.id)));
                        block.appendChild(card);
                    });
                    heroGridEl.appendChild(block);
                });
                updateHeroBadges();
                updateReadyButtonState();
            };

            const mergePlayers = (existing, local, extras = []) => {
                const set = new Set();
                const pushDecoded = (arr) => (Array.isArray(arr) ? arr : []).forEach(p => {
                    const name = decodePlayerEntry(p).name || p;
                    if (name) set.add(name);
                });
                pushDecoded(existing);
                pushDecoded(local);
                pushDecoded(extras);
                if (!set.has(lobbyHost)) set.add(lobbyHost);
                return Array.from(set);
            };

            // Poll players directly for more frequent updates (started after successful upsert)
            let pollInterval = null;
            async function pollPlayers() {
                if (!apiAvailable || !joinKeyVal) return;
                try {
                    const playerQuery = sessionUsername || lobbyHost || "Unknown";
                    const res = await fetch(`${apiBase}/api/lobbies/${encodeURIComponent(joinKeyVal)}?player=${encodeURIComponent(playerQuery)}`);
                    if (res.ok) {
                    const json = await res.json();
                    if (json?.lobby?.host) {
                        serverHost = json.lobby.host;
                    }
                    if (json?.lobby?.readyState) {
                        readyState = json.lobby.readyState;
                    }
                    const players = json?.lobby?.players;
                    if (Array.isArray(players)) {
                        currentPlayers = decodeAndMergePlayers(players);
                        // Self-heal if this client or host is missing from server record
                        const needsSelf = sessionUsername && !currentPlayers.includes(sessionUsername);
                        const needsHost = (serverHost || lobbyHost) && !currentPlayers.includes(serverHost || lobbyHost);
                        if (needsSelf || needsHost) {
                            try {
                                await fetch(`${apiBase}/api/lobbies/join`, {
                                    method: "POST",
                                    headers: { "Content-Type": "application/json" },
                                    body: JSON.stringify({
                                        key: joinKeyVal,
                                        player: sessionUsername || lobbyHost
                                    })
                                });
                            } catch (e) {
                                console.warn("[lobby] Self-heal join failed", e);
                            }
                        }
                        renderPlayers(players);
                    }
                }
                } catch (e) {
                    console.warn("[lobby] Poll players failed", e);
                }
            }
            function startPolling() {
                if (pollInterval) return;
                pollPlayers();
                pollInterval = setInterval(pollPlayers, 1000);
            }

            if (readyBtn) {
                readyBtn.dataset.ready = "false";
                readyBtn.classList.remove("clickable");
                readyBtn.addEventListener("click", () => {
                    const canToggle = readyBtn.classList.contains("clickable") && selectedHeroes.length === 3;
                    if (!canToggle) return;
                    const isReadyNow = readyBtn.dataset.ready === "true";
                    const nextState = !isReadyNow;
                    readyBtn.dataset.ready = nextState ? "true" : "false";
                    if (nextState) {
                        readyPlayers.add(sessionUsername);
                        playerSelections.set(sessionUsername, [...selectedHeroes]);
                    } else {
                        readyPlayers.delete(sessionUsername);
                    }
                    persistSelfReadyState();
                    updateReadyButtonState();
                    updateStartButtonState();
                    sendReadyState();
                });
            }

            renderHeroSelector();
            applyReadyState(readyState);
            renderPlayers(playerList);
            saveLocalReadyState();
            if (localSelfReady) {
                sendReadyState();
            }

            if (joinKeyVal && apiAvailable) {
                console.log("[lobby] Registering lobby with server", { joinKeyVal, lobbyHost, playerList, difficulty: data.difficulty, isPrivate: data.privacy === true || String(data.privacy).toLowerCase() === "private" });
                try {
                    const existingPlayers = Array.isArray(existingLobby?.players) ? existingLobby.players : [];
                    const mergedPlayers = mergePlayers(existingPlayers, playerList, [sessionUsername]);

                    const upsertRes = await fetch(`${apiBase}/api/lobbies/upsert`, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            key: joinKeyVal,
                            encrypted,
                            isPrivate: data.privacy === true || String(data.privacy).toLowerCase() === "private",
                            difficulty: data.difficulty || "Unknown",
                            host: lobbyHost,
                            players: mergedPlayers.map(encodePlayerEntry),
                            readyState
                        })
                    });
                    console.log("[lobby] upsert status", upsertRes.status);
                    if (upsertRes.ok) {
                        // Record this client as joined to ensure presence server-side
                        try {
                            await fetch(`${apiBase}/api/lobbies/join`, {
                                method: "POST",
                                headers: { "Content-Type": "application/json" },
                                body: JSON.stringify({ key: joinKeyVal, player: sessionUsername })
                            });
                        } catch (e) {
                            console.warn("[lobby] Failed to record join for session user", e);
                        }

                        const res = await fetch(`${apiBase}/api/lobbies/${encodeURIComponent(joinKeyVal)}`);
                        console.log("[lobby] fetch lobby status", res.status);
                        if (res.ok) {
                            const json = await res.json();
                            console.log("[lobby] Server lobby snapshot", json);
                            if (json?.lobby?.players) {
                                console.log("[lobby] Players in lobby:", json.lobby.players);
                                renderPlayers(json.lobby.players);
                            }
                            if (json?.lobby?.readyState) {
                                readyState = json.lobby.readyState;
                                applyReadyState(readyState);
                            }
                        }
                        startPolling();
                    }
                } catch (err) {
                    console.error("[lobby] Failed to register lobby", err);
                }
            } else if (!joinKeyVal) {
                console.warn("[lobby] No join key found; cannot broadcast lobby to server");
            } else {
                console.warn("[lobby] API not available in this environment; skipping server broadcast");
            }

            // Heartbeat to keep lobby active in listing
            const heartbeat = async () => {
                if (!apiAvailable || !joinKeyVal) return;
                try {
                    await fetch(`${apiBase}/api/lobbies/heartbeat`, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ key: joinKeyVal, player: sessionUsername || lobbyHost })
                    });
                } catch (e) {
                    console.warn("[lobby] Heartbeat failed", e);
                }
            };
            heartbeat();
            const hbInterval = setInterval(heartbeat, 1000);

            window.addEventListener("beforeunload", () => {
                clearInterval(hbInterval);
                clearInterval(pollInterval);
                if (navigator.sendBeacon && apiAvailable && joinKeyVal) {
                    const blob = new Blob([JSON.stringify({ key: joinKeyVal })], { type: "application/json" });
                    navigator.sendBeacon(`${apiBase}/api/lobbies/heartbeat`, blob);
                }
            });

            // ---------- Build readable lists ----------

            // Update privacy readout banner
            const privacyReadoutEl = document.getElementById("privacy-readout");
            let isPrivate = false;
            if (privacyReadoutEl) {
                isPrivate = data.privacy === true || String(data.privacy).toLowerCase() === "private";
                privacyReadoutEl.textContent = isPrivate ? "Private Lobby" : "Public Lobby";
            }

            // Populate join key box and copy handler
            const joinKeyText = document.getElementById("join-key-text");
            const joinKeyBtn  = document.getElementById("join-key-copy");
            const joinKeyBox  = document.getElementById("join-key-box");
            const joinKeyNote = document.getElementById("join-key-note");

            if (!isPrivate) {
                if (joinKeyBox) joinKeyBox.style.display = "none";
                if (joinKeyNote) {
                    joinKeyNote.textContent = "";
                    joinKeyNote.style.display = "none";
                }
            } else {
                if (joinKeyBox) joinKeyBox.style.display = "flex";
                if (joinKeyNote) {
                    joinKeyNote.textContent = "Copy and share this key with your friends to join your game!";
                    joinKeyNote.style.display = "";
                }
            }

            if (joinKeyText) {
                joinKeyText.textContent = joinKeyVal || "No Join Key";
            }

            if (joinKeyBtn) {
                joinKeyBtn.disabled = !joinKeyVal;
                joinKeyBtn.style.opacity = joinKeyVal ? "1" : "0.6";
                const baseTransform = joinKeyBtn.style.transform || "translateY(-50%)";
                joinKeyBtn.dataset.baseTransform = baseTransform;

                joinKeyBtn.addEventListener("click", async () => {
                    if (!joinKeyVal) return;
                    joinKeyBtn.style.transform = `${joinKeyBtn.dataset.baseTransform} scale(0.92)`;
                    setTimeout(() => {
                        joinKeyBtn.style.transform = joinKeyBtn.dataset.baseTransform;
                    }, 160);
                    try {
                        await navigator.clipboard.writeText(joinKeyVal);
                    } catch (err) {
                        console.warn("[JoinKey] Clipboard write failed", err);
                    }
                });
            }

            const overlordList = (data.overlords || [])
                .map(id => overlordMap.get(String(id)) || { name:`Unknown (ID ${id})`, hp:'?', level:'?' })
                .sort((a,b) => (Number(a.level) || 0) - (Number(b.level) || 0) || (Number(a.hp) || 0) - (Number(b.hp) || 0));

            const tacticList = (data.tactics || []).map(id => {
                const t = tacticMap.get(String(id));
                if (!t) return { name:`Unknown (ID ${id})`, abilitiesText:[{ text:'?' }] };
                return t;
            });

            const enemiesData = data.enemies || {};
            const enemiesIds  = Array.isArray(enemiesData.ids) ? enemiesData.ids : [];
            const enemiesList = enemiesIds.map(id => enemyMap.get(String(id)) || { name:`Unknown (ID ${id})` });

            const alliesData = data.allies || {};
            const alliesIds  = Array.isArray(alliesData.ids) ? alliesData.ids : [];
            const alliesList = alliesIds.map(id => allyMap.get(String(id)) || { name:`Unknown (ID ${id})` });

            const villainDeck = data.villainDeck || {};
            const mightsCount = Number(villainDeck.mights) || 0;

            const bysData  = villainDeck.bystanders || { count:0, byType:[] };
            const bysTotal = Number(bysData.count) || 0;
            const bysBreakdown = Array.isArray(bysData.byType) ? bysData.byType : [];

            const scenariosIds = Array.isArray(villainDeck.scenarios) ? villainDeck.scenarios : [];
            const scenariosList = scenariosIds.map(id => scenarioMap.get(String(id)) || { name:`Unknown (ID ${id})` });

            const henchArr = Array.isArray(villainDeck.henchmen) ? villainDeck.henchmen : [];
            const henchList = henchArr.map(hc => {
                const card = henchMap.get(String(hc.id)) || { name:`Unknown (ID ${hc.id})`, hp:'?', damage:'?' };
                return { ...card, qty: hc.count };
            });

            const villainIds = Array.isArray(villainDeck.villains) ? villainDeck.villains : [];
            const villainList = villainIds.map(id => villainMap.get(String(id)) || { name:`Unknown (ID ${id})`, hp:'?' });

            // Rotating lobby info
            const rotA = document.getElementById("rotator-text-a");
            const rotB = document.getElementById("rotator-text-b");
            const rotWrapper = document.getElementById("rotator-text-wrapper");
            const rotDiff = document.getElementById("rotator-difficulty");
            let activeRotatorLine = rotA;
            let inactiveRotatorLine = rotB;
            if (rotDiff) {
                const diffRaw = data.difficulty ?? "Unknown";
                const diffCap = typeof diffRaw === "string" && diffRaw.length
                    ? diffRaw.charAt(0).toUpperCase() + diffRaw.slice(1)
                    : diffRaw;
                rotDiff.textContent = `Difficulty: ${diffCap}`;
            }

            const setIdleStates = () => {
                activeRotatorLine.className = "rotator-line rotator-active";
                inactiveRotatorLine.className = "rotator-line rotator-hidden";
            };

            const swapRotatorText = (html, animate = true) => {
                if (!rotWrapper || !activeRotatorLine || !inactiveRotatorLine) return;
                if (!animate) {
                    activeRotatorLine.innerHTML = html;
                    setIdleStates();
                    return;
                }

                inactiveRotatorLine.innerHTML = html;
                inactiveRotatorLine.className = "rotator-line rotator-hidden";
                activeRotatorLine.className = "rotator-line rotator-active";

                // Reset animations
                activeRotatorLine.style.animation = "none";
                inactiveRotatorLine.style.animation = "none";
                // Force layout so the animation restart sticks
                activeRotatorLine.getBoundingClientRect();
                inactiveRotatorLine.getBoundingClientRect();
                activeRotatorLine.style.animation = "";
                inactiveRotatorLine.style.animation = "";

                let finished = 0;
                const handleDone = () => {
                    finished += 1;
                    if (finished === 2) {
                        [activeRotatorLine, inactiveRotatorLine] = [inactiveRotatorLine, activeRotatorLine];
                        setIdleStates();
                    }
                };

                activeRotatorLine.addEventListener("animationend", handleDone, { once: true });
                inactiveRotatorLine.addEventListener("animationend", handleDone, { once: true });

                activeRotatorLine.classList.add("rotator-anim-out");
                inactiveRotatorLine.classList.add("rotator-anim-in");
            };

            const randPick = (list) => list.length ? list[Math.floor(Math.random() * list.length)] : null;
            const snippets = [];

            if (overlordList.length) {
                const o = randPick(overlordList);
                if (o) snippets.push(`Overlord: ${o.name}`);
            }
            if (tacticList.length) {
                const t = randPick(tacticList);
                if (t) snippets.push(`Tactic: ${t.name}`);
            }
            if (enemiesList.length) {
                const e = randPick(enemiesList);
                if (e) snippets.push(`Enemy: ${e.name}`);
            }
            if (alliesList.length) {
                const a = randPick(alliesList);
                if (a) snippets.push(`Ally: ${a.name}`);
            }
            if (villainList.length) {
                const v = randPick(villainList);
                if (v) snippets.push(`Villain: ${v.name}`);
            }

            const uniqueHench = (() => {
                const map = new Map();
                (henchList || []).forEach(h => {
                    if (!h || !h.name) return;
                    if (!map.has(h.name)) map.set(h.name, h);
                });
                return Array.from(map.values());
            })();
            if (uniqueHench.length) {
                const h = randPick(uniqueHench);
                if (h) snippets.push(`Henchmen: ${h.name}`);
            }

            if (scenariosList.length) {
                const s = randPick(scenariosList);
                if (s) snippets.push(`Scenario: ${s.name}`);
            }

            const shuffled = snippets
                .map(v => ({ v, r: Math.random() }))
                .sort((a, b) => a.r - b.r)
                .map(o => o.v);

            let rotIndex = 0;
            const rotate = () => {
                if (!shuffled.length) return;
                swapRotatorText(`<span style="text-decoration: underline;">Coming Up:</span> ${shuffled[rotIndex]}`);
                rotIndex = (rotIndex + 1) % shuffled.length;
            };
            if (shuffled.length) {
                swapRotatorText(`<span style="text-decoration: underline;">Coming Up:</span> ${shuffled[rotIndex]}`, false);
                rotIndex = (rotIndex + 1) % shuffled.length;
                setInterval(rotate, 5000);
            }

            /*
            const area = document.createElement("div");
            area.style.color = "black";
            area.style.marginTop = "40px";
            area.style.textAlign = "center";

            const privacyBlock = data.privacy === "private"
                ? `<p><b>Join Key:</b> ${data.key}</p>`
                : `<p>This lobby is public, no join key required.</p>`;

            area.innerHTML = `
                <h2>Lobby Created</h2>
                <p><b>Privacy:</b> ${data.privacy === true || data.privacy === "private" ? "Private Lobby" : "Public Lobby"}</p>
                ${privacyBlock}
                <p><b>Difficulty:</b> ${data.difficulty}</p>

                <h3 style="margin-top:30px;">Overlords</h3>
                <ol style="display:inline-block; text-align:left;">
                    ${overlordList.map(o => `
                        <li>${o.name} — ${o.hp} HP (Difficulty ${o.level})</li>
                    `).join('')}
                </ol>

                <h3 style="margin-top:30px;">Tactics</h3>
                <ol style="display:inline-block; text-align:left; max-width:700px;">
                    ${tacticList.map(t => `
                        <li style="margin-bottom:10px;">
                            <b>${t.name}</b><br>
                            ${(t.abilitiesText || []).map(a => a.text).join('<br>')}
                        </li>
                    `).join('')}
                </ol>

                <h3 style="margin-top:30px;">Enemies & Allies</h3>
                <p>Enemies: ${enemiesIds.length} &nbsp; | &nbsp; Allies: ${alliesIds.length}</p>
                <div style="display:flex; justify-content:center; gap:40px; flex-wrap:wrap; text-align:left;">
                    <div>
                        <b>Enemies:</b>
                        <ol>
                            ${enemiesList.map(e => `<li>${e.name}</li>`).join('')}
                        </ol>
                    </div>
                    <div>
                        <b>Allies:</b>
                        <ol>
                            ${alliesList.map(a => `<li>${a.name}</li>`).join('')}
                        </ol>
                    </div>
                </div>

                <h3 style="margin-top:30px;">Villain Deck</h3>
                <p><b>Mights:</b> ${mightsCount}</p>

                <h4>Bystanders (${bysTotal})</h4>
                <ul style="display:inline-block; text-align:left;">
                    ${bysBreakdown.map(b => `
                        <li>${(b.name || bystanderMap.get(String(b.id))?.name || 'Unknown')} — ${b.count}</li>
                    `).join('')}
                </ul>

                <h4 style="margin-top:20px;">Scenarios (${scenariosIds.length})</h4>
                <ol style="display:inline-block; text-align:left;">
                    ${scenariosList.map(s => `<li>${s.name}</li>`).join('')}
                </ol>

                <h4 style="margin-top:20px;">Henchmen</h4>
                <p>Total cards: ${henchList.reduce((sum, h) => sum + (Number(h.qty)||0), 0)}</p>
                <ol style="display:inline-block; text-align:left;">
                    ${henchList.map(h => `
                        <li>${h.name} — ${h.hp}/${h.damage} × ${h.qty}</li>
                    `).join('')}
                </ol>

                <h4 style="margin-top:20px;">Villains (${villainIds.length})</h4>
                <ol style="display:inline-block; text-align:left;">
                    ${villainList.map(v => `<li>${v.name} — ${v.hp} HP</li>`).join('')}
                </ol>

                <br>
            `;
            document.querySelector(".container").appendChild(area);
            */

            // --- Send data to game.html (same method as single.html) ---
            async function encryptData(data, secretKey) {
                const enc = new TextEncoder();
                const iv = crypto.getRandomValues(new Uint8Array(12));

                const keyMaterial = await crypto.subtle.digest("SHA-256", enc.encode(secretKey));
                const key = await crypto.subtle.importKey("raw", keyMaterial, { name: "AES-GCM" }, false, ["encrypt"]);

                const encoded = enc.encode(JSON.stringify(data));
                const encrypted = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, encoded);

                const combined = new Uint8Array(iv.length + encrypted.byteLength);
                combined.set(iv);
                combined.set(new Uint8Array(encrypted), iv.length);

                return btoa(String.fromCharCode(...combined));
            }

            if (launchBtn) {
                launchBtn.style.display = isHost ? "block" : "none";
                launchBtn.classList.remove("clickable");
            }

            if (launchBtn && isHost) launchBtn.addEventListener("click", async () => {
                if (!launchBtn.classList.contains("clickable")) return;
                const SECRET = "GeimonHeroKey42";

                data.playerUsernames = data.playerUsernames || [];
                data.heroesByPlayer = data.heroesByPlayer || [];
                data.players = currentPlayers;
                const heroesByPlayer = currentPlayers.map(p => playerSelections.get(p) || []);

                // Construct hero turn order by player count rules
                const orderedHeroes = [];
                const count = heroesByPlayer.length;
                if (count === 2) {
                    for (let round = 0; round < 3; round++) {
                        for (let p = 0; p < 2; p++) {
                            const hero = heroesByPlayer[p][round];
                            if (hero != null) orderedHeroes.push(hero);
                        }
                    }
                } else if (count === 3) {
                    for (let round = 0; round < 2; round++) {
                        for (let p = 0; p < 3; p++) {
                            const hero = heroesByPlayer[p][round];
                            if (hero != null) orderedHeroes.push(hero);
                        }
                    }
                } else if (count === 4) {
                    for (let p = 0; p < 4; p++) {
                        const hero = heroesByPlayer[p][0];
                        if (hero != null) orderedHeroes.push(hero);
                    }
                    const hostExtras = heroesByPlayer[0] || [];
                    if (hostExtras[1] != null) orderedHeroes.push(hostExtras[1]);
                    if (hostExtras[2] != null) orderedHeroes.push(hostExtras[2]);
                } else if (count === 5) {
                    for (let p = 0; p < 5; p++) {
                        const hero = heroesByPlayer[p][0];
                        if (hero != null) orderedHeroes.push(hero);
                    }
                    const hostExtras = heroesByPlayer[0] || [];
                    if (hostExtras[1] != null) orderedHeroes.push(hostExtras[1]);
                } else if (count >= 6) {
                    for (let p = 0; p < count; p++) {
                        const hero = heroesByPlayer[p][0];
                        if (hero != null) orderedHeroes.push(hero);
                    }
                } else {
                    heroesByPlayer.forEach(list => list.forEach(h => { if (h != null) orderedHeroes.push(h); }));
                }

                data.heroesByPlayer = heroesByPlayer.map((heroes, idx) => ({ player: currentPlayers[idx], heroes }));
                data.heroes = orderedHeroes;
                data.heroTurnOrder = orderedHeroes;
                data.selectedHeroes = orderedHeroes;
                data.heroData = data.heroData || {};
                orderedHeroes.forEach((hid, i) => {
                    const key = String(hid);
                    if (!data.heroData[key]) data.heroData[key] = {};
                    data.heroData[key].owner = data.heroData[key].owner || currentPlayers[i % currentPlayers.length];
                });

                const encrypted = await encryptData(data, SECRET);

                const url = new URL("./game.html", window.location.href);
                url.searchParams.set("data", encrypted);

                // Mark lobby started so it disappears from listings
                try {
                    if (apiAvailable && joinKeyVal) {
                        await fetch(`${apiBase}/api/lobbies/start`, {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({ key: joinKeyVal })
                        });
                    }
                } catch (e) {
                    console.warn("[lobby] Failed to mark lobby started", e);
                }

                window.open(url.toString(), "_self");
            });
        })();
    </script>
</body>
</html>


