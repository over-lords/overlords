<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover">
    <link href='https://fonts.googleapis.com/css?family=Racing Sans One' rel='stylesheet'>
    <link rel="icon" href="favicon.png">
    <link rel="icon" href="https://raw.githubusercontent.com/over-lords/overlords/4c614c1ffe5a9d7194202bd24fae5e7c99d86333/Public/Images/Site%20Assets/favicon.png" type="image/png">
    <link rel="stylesheet" href="style.css">
    <style>
        #rotator-text-wrapper {
            position: relative;
            width: 100%;
            height: 18px;
            overflow: hidden;
        }
        .rotator-line {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            font-size: 14px;
            line-height: 1.3;
            color: #111;
            text-shadow: 1px 1px 0 #fff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            transform: translateY(-120%);
            opacity: 0;
        }
        .rotator-active {
            transform: translateY(0);
            opacity: 1;
        }
        .rotator-hidden {
            transform: translateY(-120%);
            opacity: 0;
        }
        .rotator-anim-in {
            animation: rotatorSlideIn 0.45s ease forwards;
        }
        .rotator-anim-out {
            animation: rotatorSlideOut 0.45s ease forwards;
        }
        @keyframes rotatorSlideIn {
            from { transform: translateY(-120%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        @keyframes rotatorSlideOut {
            from { transform: translateY(0); opacity: 1; }
            to { transform: translateY(120%); opacity: 0; }
        }
    </style>
    <title>Overlords</title>
</head>
<body style="background-color:white;">
    <div class="bg-image" alt="" style="opaCity: 35%;"></div>
    <div class="container">
        <div class="title-box" id="title-box"></div>
        <h1 class="glow-red" style="pointer-events: none;">Lobby</h1>

        <div id="close-box" onclick="location.href='multi.html'">X</div>

        <div class="deck-box" id="launch-btn" style="display: none; cursor: pointer; margin-top: -60px;">
            <h1 class="menu-text" style="margin-top: 0px; pointer-events: none;">Launch!</h1>
        </div>

        <br><br><br><br><br><br>

        <div style="margin-top: 10px; width: 100%; display: flex; flex-direction: column; gap: 14px;">
            <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
                <div id="privacy-readout" style="font-size: 32px; font-family: 'Racing Sans One', sans-serif; color: #fff; text-shadow: 0 0 6px #000; padding-left: 10px;"></div>
            </div>
        </div>

        <div id="player-list-box" style="margin-top: 20px; width: 320px; background: #ededed; border: 6px solid #000; border-radius: 10px; box-shadow: 0 6px 18px rgba(0,0,0,0.25); padding: 10px; color: #111; font-family: 'Racing Sans One', sans-serif;">
            <div style="font-size: 22px; font-weight: bold; margin-bottom: 8px; text-shadow: 1px 1px 0 #fff;">Players in Lobby</div>
            <div id="player-list-count" style="font-size: 16px; margin-bottom: 6px;"></div>
            <ul id="player-list" style="list-style: none; padding: 0; margin: 0; display: flex; flex-direction: column; gap: 4px;"></ul>
        </div>

        <div id="lobby-rotator" style="position: fixed; right: 15px; top: 88%; transform: translateY(-50%); width: 320px; height: 60px; background: #ededed; border: 6px solid #000; border-radius: 10px; box-shadow: 0 6px 18px rgba(0,0,0,0.25); padding: 4px 8px; color: #222; font-family: 'Racing Sans One', sans-serif; pointer-events: none; z-index: 9;">
            <div id="rotator-difficulty" style="font-size: 20px; text-shadow: 1px 1px 0 #fff;">Difficulty:</div>
            <div style="margin-top: 2px; padding: 4px; background: #fff; border: 3px solid #000; border-radius: 6px; min-height: 0px; display: flex; align-items: center; justify-content: flex-start;">
                <div id="rotator-text-wrapper">
                    <div id="rotator-text-a" class="rotator-line rotator-active"></div>
                    <div id="rotator-text-b" class="rotator-line rotator-hidden"></div>
                </div>
            </div>
        </div>

        <div id="join-key-box" style="position: fixed; right: 15px; top: 50%; transform: translateY(-50%); width: 300px; height: 70px; background: #ededed; border: 6px solid black; color: #000; font-family: 'Racing Sans One', sans-serif; box-shadow: 0 4px 12px rgba(0,0,0,0.3); border-radius: 8px; padding: 8px; box-sizing: border-box; display: flex; align-items: center; justify-content: flex-start; text-align: left; pointer-events: auto; z-index: 10; overflow: hidden;">
            <span id="join-key-text" style="font-size: 2.8rem; flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;"></span>
            <button id="join-key-copy" type="button" style="position: absolute; right: -12px; top: 50%; transform: translateY(-50%); height: 44px; padding: 0 14px; border: none; border-radius: 4px; background: #222; color: #fff; font-weight: bold; cursor: pointer; box-shadow: 0 2px 6px rgba(0,0,0,0.25); font-size: 1.5rem; margin-right: 14px; line-height: 50px;">⧉</button>
        </div>
        <div id="join-key-note" style="position: fixed; right: 15px; top: calc(50% + 70px); transform: translateY(-50%); width: 300px; color: #333; font-family: 'Racing Sans One', sans-serif; font-size: 16px; text-align: center; text-shadow: 1px 1px 0 #fff;">Copy and share this key with your friends to join your game!</div>
    </div>

    <script type="module">
        import { supabase } from './supabaseClient.js';
        import { getSessionUserId } from './utils/session.js';
        import { overlords } from './data/overlords.js';
        import { tactics } from './data/tactics.js';
        import { enemies } from './data/enemies.js';
        import { allies } from './data/allies.js';
        import { bystanders } from './data/bystanders.js';
        import { scenarios } from './data/scenarios.js';
        import { henchmen } from './data/henchmen.js';
        import { villains } from './data/villains.js';

        window.GAME_MODE = "multi";

        async function decrypt(cipherText, secretKey) {
            const data = atob(cipherText);
            const bytes = new Uint8Array([...data].map(c => c.charCodeAt(0)));
            const iv = bytes.slice(0, 12);
            const cipher = bytes.slice(12);

            const keyMaterial = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(secretKey));
            const key = await crypto.subtle.importKey("raw", keyMaterial, { name:"AES-GCM" }, false, ["decrypt"]);

            const decrypted = await crypto.subtle.decrypt({ name:"AES-GCM", iv }, key, cipher);
            return JSON.parse(new TextDecoder().decode(decrypted));
        }

        (async () => {
            const params = new URLSearchParams(window.location.search);
            const encrypted = params.get("data");
            const SECRET = "GeimonHeroKey42";
            const playerListEl = document.getElementById("player-list");
            const playerCountEl = document.getElementById("player-list-count");

            if (!encrypted) {
                document.body.insertAdjacentHTML("beforeend","<p style='color:red'>No lobby data found.</p>");
                return;
            }

            let data;
            try {
                data = await decrypt(encrypted, SECRET);
            } catch (e) {
                console.error(e);
                document.body.insertAdjacentHTML("beforeend","<p style='color:red'>Failed to decrypt lobby data.</p>");
                return;
            }
            const apiBase = "https://overlords-app-43e6e621c6d2.herokuapp.com";
            const apiAvailable = !!apiBase;

            let sessionUsername = "Host";
            try {
                const uid = getSessionUserId();
                if (uid) {
                    const { data: user, error } = await supabase
                        .from("users")
                        .select("username")
                        .eq("id", uid)
                        .single();
                    if (user?.username && !error) {
                        sessionUsername = user.username;
                    }
                }
            } catch (e) {
                console.warn("[lobby] Failed to load session username", e);
            }

            let joinKeyVal = data.key || data.joinKey || "";

            // Ensure every lobby (even public) has a key so it can be listed/joined
            if (!joinKeyVal) {
                joinKeyVal = Math.random().toString().slice(2, 10);
                data.key = joinKeyVal;
                console.log("[lobby] Generated join key for public lobby", joinKeyVal);
            }

            // Fetch existing lobby first to capture host/players
            let existingLobby = null;
            if (apiAvailable && joinKeyVal) {
                try {
                    const res = await fetch(`${apiBase}/api/lobbies/${encodeURIComponent(joinKeyVal)}`);
                    if (res.ok) {
                        const json = await res.json();
                        existingLobby = json?.lobby || null;
                    }
                } catch (e) {
                    console.warn("[lobby] Could not prefetch existing lobby", e);
                }
            }

            const existingHost = existingLobby?.host;
            const lobbyHost = existingHost || data.username || data.host || sessionUsername;
            const playerList = Array.isArray(data.players) && data.players.length ? data.players : [lobbyHost];

            const renderPlayers = (list) => {
                if (!playerListEl || !playerCountEl) return;
                const safeList = Array.isArray(list) ? list.filter(Boolean) : [];
                // Ensure host is present at least once
                if (safeList.length === 0 || !safeList.includes(lobbyHost)) {
                    safeList.unshift(lobbyHost);
                }
                playerCountEl.textContent = `${safeList.length} player${safeList.length === 1 ? "" : "s"}`;
                playerListEl.innerHTML = "";
                if (!safeList.length) {
                    const li = document.createElement("li");
                    li.textContent = "No players yet";
                    playerListEl.appendChild(li);
                    return;
                }
                safeList.forEach(name => {
                    const li = document.createElement("li");
                    li.textContent = name;
                    li.style.fontSize = "16px";
                    li.style.padding = "2px 6px";
                    li.style.border = "1px solid #ccc";
                    li.style.borderRadius = "6px";
                    li.style.background = "#fff";
                    playerListEl.appendChild(li);
                });
            };

            const mergePlayers = (existing, local) => {
                const set = new Set();
                (Array.isArray(existing) ? existing : []).forEach(p => set.add(p));
                (Array.isArray(local) ? local : []).forEach(p => set.add(p));
                if (!set.has(lobbyHost)) set.add(lobbyHost);
                return Array.from(set);
            };

            if (joinKeyVal && apiAvailable) {
                console.log("[lobby] Registering lobby with server", { joinKeyVal, lobbyHost, playerList, difficulty: data.difficulty, isPrivate: data.privacy === true || String(data.privacy).toLowerCase() === "private" });
                try {
                    const existingPlayers = Array.isArray(existingLobby?.players) ? existingLobby.players : [];
                    const mergedPlayers = mergePlayers(existingPlayers, playerList);

                    const upsertRes = await fetch(`${apiBase}/api/lobbies/upsert`, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            key: joinKeyVal,
                            encrypted,
                            isPrivate: data.privacy === true || String(data.privacy).toLowerCase() === "private",
                            difficulty: data.difficulty || "Unknown",
                            host: lobbyHost,
                            players: mergedPlayers
                        })
                    });
                    console.log("[lobby] upsert status", upsertRes.status);
                    if (upsertRes.ok) {
                        const res = await fetch(`${apiBase}/api/lobbies/${encodeURIComponent(joinKeyVal)}`);
                        console.log("[lobby] fetch lobby status", res.status);
                        if (res.ok) {
                            const json = await res.json();
                            console.log("[lobby] Server lobby snapshot", json);
                            if (json?.lobby?.players) {
                                console.log("[lobby] Players in lobby:", json.lobby.players);
                                renderPlayers(json.lobby.players);
                            }
                        }
                    }
                } catch (err) {
                    console.error("[lobby] Failed to register lobby", err);
                }
            } else if (!joinKeyVal) {
                console.warn("[lobby] No join key found; cannot broadcast lobby to server");
            } else {
                console.warn("[lobby] API not available in this environment; skipping server broadcast");
            }

            // Heartbeat to keep lobby active in listing
            const heartbeat = async () => {
                if (!apiAvailable || !joinKeyVal) return;
                try {
                    await fetch(`${apiBase}/api/lobbies/heartbeat`, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ key: joinKeyVal })
                    });
                } catch (e) {
                    console.warn("[lobby] Heartbeat failed", e);
                }
            };
            heartbeat();
            const hbInterval = setInterval(heartbeat, 5000);

            // Poll players directly for more frequent updates
            const pollPlayers = async () => {
                if (!apiAvailable || !joinKeyVal) return;
                try {
                    const res = await fetch(`${apiBase}/api/lobbies/${encodeURIComponent(joinKeyVal)}`);
                    if (res.ok) {
                        const json = await res.json();
                        if (json?.lobby?.players) renderPlayers(json.lobby.players);
                    }
                } catch (e) {
                    console.warn("[lobby] Poll players failed", e);
                }
            };
            pollPlayers();
            const pollInterval = setInterval(pollPlayers, 5000);

            window.addEventListener("beforeunload", () => {
                clearInterval(hbInterval);
                clearInterval(pollInterval);
                if (navigator.sendBeacon && apiAvailable && joinKeyVal) {
                    const blob = new Blob([JSON.stringify({ key: joinKeyVal })], { type: "application/json" });
                    navigator.sendBeacon(`${apiBase}/api/lobbies/heartbeat`, blob);
                }
            });

            // ---------- Build readable lists ----------

            const overlordMap = new Map(overlords.map(o => [String(o.id), o]));
            const tacticMap   = new Map(tactics.map(t => [String(t.id), t]));
            const enemyMap    = new Map(enemies.map(e => [String(e.id), e]));
            const allyMap     = new Map(allies.map(a => [String(a.id), a]));
            const bystanderMap= new Map(bystanders.map(b => [String(b.id), b]));
            const scenarioMap = new Map(scenarios.map(s => [String(s.id), s]));
            const henchMap    = new Map(henchmen.map(h => [String(h.id), h]));
            const villainMap  = new Map(villains.map(v => [String(v.id), v]));

            // Update privacy readout banner
            const privacyReadoutEl = document.getElementById("privacy-readout");
            let isPrivate = false;
            if (privacyReadoutEl) {
                isPrivate = data.privacy === true || String(data.privacy).toLowerCase() === "private";
                privacyReadoutEl.textContent = isPrivate ? "Private Lobby" : "Public Lobby";
            }

            // Populate join key box and copy handler
            const joinKeyText = document.getElementById("join-key-text");
            const joinKeyBtn  = document.getElementById("join-key-copy");
            const joinKeyBox  = document.getElementById("join-key-box");
            const joinKeyNote = document.getElementById("join-key-note");

            if (!isPrivate) {
                if (joinKeyBox) joinKeyBox.style.display = "none";
                if (joinKeyNote) {
                    joinKeyNote.textContent = "";
                    joinKeyNote.style.display = "none";
                }
            } else {
                if (joinKeyBox) joinKeyBox.style.display = "flex";
                if (joinKeyNote) {
                    joinKeyNote.textContent = "Copy and share this key with your friends to join your game!";
                    joinKeyNote.style.display = "";
                }
            }

            if (joinKeyText) {
                joinKeyText.textContent = joinKeyVal || "No Join Key";
            }

            if (joinKeyBtn) {
                joinKeyBtn.disabled = !joinKeyVal;
                joinKeyBtn.style.opacity = joinKeyVal ? "1" : "0.6";
                const baseTransform = joinKeyBtn.style.transform || "translateY(-50%)";
                joinKeyBtn.dataset.baseTransform = baseTransform;

                joinKeyBtn.addEventListener("click", async () => {
                    if (!joinKeyVal) return;
                    joinKeyBtn.style.transform = `${joinKeyBtn.dataset.baseTransform} scale(0.92)`;
                    setTimeout(() => {
                        joinKeyBtn.style.transform = joinKeyBtn.dataset.baseTransform;
                    }, 160);
                    try {
                        await navigator.clipboard.writeText(joinKeyVal);
                    } catch (err) {
                        console.warn("[JoinKey] Clipboard write failed", err);
                    }
                });
            }

            const overlordList = (data.overlords || [])
                .map(id => overlordMap.get(String(id)) || { name:`Unknown (ID ${id})`, hp:'?', level:'?' })
                .sort((a,b) => (Number(a.level) || 0) - (Number(b.level) || 0) || (Number(a.hp) || 0) - (Number(b.hp) || 0));

            const tacticList = (data.tactics || []).map(id => {
                const t = tacticMap.get(String(id));
                if (!t) return { name:`Unknown (ID ${id})`, abilitiesText:[{ text:'?' }] };
                return t;
            });

            const enemiesData = data.enemies || {};
            const enemiesIds  = Array.isArray(enemiesData.ids) ? enemiesData.ids : [];
            const enemiesList = enemiesIds.map(id => enemyMap.get(String(id)) || { name:`Unknown (ID ${id})` });

            const alliesData = data.allies || {};
            const alliesIds  = Array.isArray(alliesData.ids) ? alliesData.ids : [];
            const alliesList = alliesIds.map(id => allyMap.get(String(id)) || { name:`Unknown (ID ${id})` });

            const villainDeck = data.villainDeck || {};
            const mightsCount = Number(villainDeck.mights) || 0;

            const bysData  = villainDeck.bystanders || { count:0, byType:[] };
            const bysTotal = Number(bysData.count) || 0;
            const bysBreakdown = Array.isArray(bysData.byType) ? bysData.byType : [];

            const scenariosIds = Array.isArray(villainDeck.scenarios) ? villainDeck.scenarios : [];
            const scenariosList = scenariosIds.map(id => scenarioMap.get(String(id)) || { name:`Unknown (ID ${id})` });

            const henchArr = Array.isArray(villainDeck.henchmen) ? villainDeck.henchmen : [];
            const henchList = henchArr.map(hc => {
                const card = henchMap.get(String(hc.id)) || { name:`Unknown (ID ${hc.id})`, hp:'?', damage:'?' };
                return { ...card, qty: hc.count };
            });

            const villainIds = Array.isArray(villainDeck.villains) ? villainDeck.villains : [];
            const villainList = villainIds.map(id => villainMap.get(String(id)) || { name:`Unknown (ID ${id})`, hp:'?' });

            // Rotating lobby info
            const rotA = document.getElementById("rotator-text-a");
            const rotB = document.getElementById("rotator-text-b");
            const rotWrapper = document.getElementById("rotator-text-wrapper");
            const rotDiff = document.getElementById("rotator-difficulty");
            let activeRotatorLine = rotA;
            let inactiveRotatorLine = rotB;
            if (rotDiff) {
                const diffRaw = data.difficulty ?? "Unknown";
                const diffCap = typeof diffRaw === "string" && diffRaw.length
                    ? diffRaw.charAt(0).toUpperCase() + diffRaw.slice(1)
                    : diffRaw;
                rotDiff.textContent = `Difficulty: ${diffCap}`;
            }

            const setIdleStates = () => {
                activeRotatorLine.className = "rotator-line rotator-active";
                inactiveRotatorLine.className = "rotator-line rotator-hidden";
            };

            const swapRotatorText = (html, animate = true) => {
                if (!rotWrapper || !activeRotatorLine || !inactiveRotatorLine) return;
                if (!animate) {
                    activeRotatorLine.innerHTML = html;
                    setIdleStates();
                    return;
                }

                inactiveRotatorLine.innerHTML = html;
                inactiveRotatorLine.className = "rotator-line rotator-hidden";
                activeRotatorLine.className = "rotator-line rotator-active";

                // Reset animations
                activeRotatorLine.style.animation = "none";
                inactiveRotatorLine.style.animation = "none";
                // Force layout so the animation restart sticks
                activeRotatorLine.getBoundingClientRect();
                inactiveRotatorLine.getBoundingClientRect();
                activeRotatorLine.style.animation = "";
                inactiveRotatorLine.style.animation = "";

                let finished = 0;
                const handleDone = () => {
                    finished += 1;
                    if (finished === 2) {
                        [activeRotatorLine, inactiveRotatorLine] = [inactiveRotatorLine, activeRotatorLine];
                        setIdleStates();
                    }
                };

                activeRotatorLine.addEventListener("animationend", handleDone, { once: true });
                inactiveRotatorLine.addEventListener("animationend", handleDone, { once: true });

                activeRotatorLine.classList.add("rotator-anim-out");
                inactiveRotatorLine.classList.add("rotator-anim-in");
            };

            const randPick = (list) => list.length ? list[Math.floor(Math.random() * list.length)] : null;
            const snippets = [];

            if (overlordList.length) {
                const o = randPick(overlordList);
                if (o) snippets.push(`Overlord: ${o.name}`);
            }
            if (tacticList.length) {
                const t = randPick(tacticList);
                if (t) snippets.push(`Tactic: ${t.name}`);
            }
            if (enemiesList.length) {
                const e = randPick(enemiesList);
                if (e) snippets.push(`Enemy: ${e.name}`);
            }
            if (alliesList.length) {
                const a = randPick(alliesList);
                if (a) snippets.push(`Ally: ${a.name}`);
            }
            if (villainList.length) {
                const v = randPick(villainList);
                if (v) snippets.push(`Villain: ${v.name}`);
            }

            const uniqueHench = (() => {
                const map = new Map();
                (henchList || []).forEach(h => {
                    if (!h || !h.name) return;
                    if (!map.has(h.name)) map.set(h.name, h);
                });
                return Array.from(map.values());
            })();
            if (uniqueHench.length) {
                const h = randPick(uniqueHench);
                if (h) snippets.push(`Henchmen: ${h.name}`);
            }

            if (scenariosList.length) {
                const s = randPick(scenariosList);
                if (s) snippets.push(`Scenario: ${s.name}`);
            }

            const shuffled = snippets
                .map(v => ({ v, r: Math.random() }))
                .sort((a, b) => a.r - b.r)
                .map(o => o.v);

            let rotIndex = 0;
            const rotate = () => {
                if (!shuffled.length) return;
                swapRotatorText(`<span style="text-decoration: underline;">Coming Up:</span> ${shuffled[rotIndex]}`);
                rotIndex = (rotIndex + 1) % shuffled.length;
            };
            if (shuffled.length) {
                swapRotatorText(`<span style="text-decoration: underline;">Coming Up:</span> ${shuffled[rotIndex]}`, false);
                rotIndex = (rotIndex + 1) % shuffled.length;
                setInterval(rotate, 5000);
            }

            /*
            const area = document.createElement("div");
            area.style.color = "black";
            area.style.marginTop = "40px";
            area.style.textAlign = "center";

            const privacyBlock = data.privacy === "private"
                ? `<p><b>Join Key:</b> ${data.key}</p>`
                : `<p>This lobby is public, no join key required.</p>`;

            area.innerHTML = `
                <h2>Lobby Created</h2>
                <p><b>Privacy:</b> ${data.privacy === true || data.privacy === "private" ? "Private Lobby" : "Public Lobby"}</p>
                ${privacyBlock}
                <p><b>Difficulty:</b> ${data.difficulty}</p>

                <h3 style="margin-top:30px;">Overlords</h3>
                <ol style="display:inline-block; text-align:left;">
                    ${overlordList.map(o => `
                        <li>${o.name} — ${o.hp} HP (Difficulty ${o.level})</li>
                    `).join('')}
                </ol>

                <h3 style="margin-top:30px;">Tactics</h3>
                <ol style="display:inline-block; text-align:left; max-width:700px;">
                    ${tacticList.map(t => `
                        <li style="margin-bottom:10px;">
                            <b>${t.name}</b><br>
                            ${(t.abilitiesText || []).map(a => a.text).join('<br>')}
                        </li>
                    `).join('')}
                </ol>

                <h3 style="margin-top:30px;">Enemies & Allies</h3>
                <p>Enemies: ${enemiesIds.length} &nbsp; | &nbsp; Allies: ${alliesIds.length}</p>
                <div style="display:flex; justify-content:center; gap:40px; flex-wrap:wrap; text-align:left;">
                    <div>
                        <b>Enemies:</b>
                        <ol>
                            ${enemiesList.map(e => `<li>${e.name}</li>`).join('')}
                        </ol>
                    </div>
                    <div>
                        <b>Allies:</b>
                        <ol>
                            ${alliesList.map(a => `<li>${a.name}</li>`).join('')}
                        </ol>
                    </div>
                </div>

                <h3 style="margin-top:30px;">Villain Deck</h3>
                <p><b>Mights:</b> ${mightsCount}</p>

                <h4>Bystanders (${bysTotal})</h4>
                <ul style="display:inline-block; text-align:left;">
                    ${bysBreakdown.map(b => `
                        <li>${(b.name || bystanderMap.get(String(b.id))?.name || 'Unknown')} — ${b.count}</li>
                    `).join('')}
                </ul>

                <h4 style="margin-top:20px;">Scenarios (${scenariosIds.length})</h4>
                <ol style="display:inline-block; text-align:left;">
                    ${scenariosList.map(s => `<li>${s.name}</li>`).join('')}
                </ol>

                <h4 style="margin-top:20px;">Henchmen</h4>
                <p>Total cards: ${henchList.reduce((sum, h) => sum + (Number(h.qty)||0), 0)}</p>
                <ol style="display:inline-block; text-align:left;">
                    ${henchList.map(h => `
                        <li>${h.name} — ${h.hp}/${h.damage} × ${h.qty}</li>
                    `).join('')}
                </ol>

                <h4 style="margin-top:20px;">Villains (${villainIds.length})</h4>
                <ol style="display:inline-block; text-align:left;">
                    ${villainList.map(v => `<li>${v.name} — ${v.hp} HP</li>`).join('')}
                </ol>

                <br>
            `;
            document.querySelector(".container").appendChild(area);
            */

            // --- Send data to game.html (same method as single.html) ---
            async function encryptData(data, secretKey) {
                const enc = new TextEncoder();
                const iv = crypto.getRandomValues(new Uint8Array(12));

                const keyMaterial = await crypto.subtle.digest("SHA-256", enc.encode(secretKey));
                const key = await crypto.subtle.importKey("raw", keyMaterial, { name: "AES-GCM" }, false, ["encrypt"]);

                const encoded = enc.encode(JSON.stringify(data));
                const encrypted = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, encoded);

                const combined = new Uint8Array(iv.length + encrypted.byteLength);
                combined.set(iv);
                combined.set(new Uint8Array(encrypted), iv.length);

                return btoa(String.fromCharCode(...combined));
            }

            document.getElementById("launch-btn").addEventListener("click", async () => {
                const SECRET = "GeimonHeroKey42";

                data.playerUsernames = data.playerUsernames || [];
                data.heroesByPlayer = data.heroesByPlayer || [];

                const encrypted = await encryptData(data, SECRET);

                const url = new URL("./game.html", window.location.href);
                url.searchParams.set("data", encrypted);

                // Mark lobby started so it disappears from listings
                try {
                    if (apiAvailable && joinKeyVal) {
                        await fetch(`${apiBase}/api/lobbies/start`, {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({ key: joinKeyVal })
                        });
                    }
                } catch (e) {
                    console.warn("[lobby] Failed to mark lobby started", e);
                }

                window.open(url.toString(), "_self");
            });
        })();
    </script>
</body>
</html>


